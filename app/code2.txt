import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../widgets/app_page.dart';
import '../theme/theme_provider.dart';

class BaseNCalculatorPage extends StatefulWidget {
  const BaseNCalculatorPage({Key? key}) : super(key: key);

  @override
  State<BaseNCalculatorPage> createState() => _BaseNCalculatorPageState();
}

class _BaseNCalculatorPageState extends State<BaseNCalculatorPage> {
  final TextEditingController _inputController = TextEditingController();
  int _fromBase = 10;
  int _toBase = 2;
  String _result = '';
  String _error = '';

  final List<int> _bases = [2, 8, 10, 16];
  final Map<int, String> _baseNames = {
    2: 'Binary',
    8: 'Octal',
    10: 'Decimal',
    16: 'Hexadecimal',
  };

  void _convert() {
    setState(() {
      _error = '';
      _result = '';
    });

    try {
      final input = _inputController.text.toUpperCase().trim();

      if (input.isEmpty) {
        setState(() {
          _error = 'Please enter a number';
        });
        return;
      }

      final decimal = int.parse(input, radix: _fromBase);
      final converted = decimal.toRadixString(_toBase).toUpperCase();

      setState(() {
        _result = converted;
      });
    } catch (e) {
      setState(() {
        _error = 'Invalid input for base $_fromBase';
        _result = '';
      });
    }
  }

  void _clear() {
    setState(() {
      _inputController.clear();
      _result = '';
      _error = '';
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = context.watch<ThemeProvider>().currentTheme;

    return AppPage(
      title: 'Base-N Converter',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Input Section
          ThemedCard(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Input',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: theme.primary,
                  ),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: _inputController,
                  style: TextStyle(
                    fontSize: 18,
                    fontFamily: 'monospace',
                    color: theme.foreground,
                  ),
                  decoration: InputDecoration(
                    hintText: 'Enter number...',
                    prefixIcon: Icon(Icons.input, color: theme.primary),
                    suffixIcon: _inputController.text.isNotEmpty
                        ? IconButton(
                            icon: Icon(Icons.clear, color: theme.muted),
                            onPressed: _clear,
                          )
                        : null,
                  ),
                  onChanged: (_) => setState(() {}),
                  onSubmitted: (_) => _convert(),
                ),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // Base Selection
          ThemedCard(
            child: Column(
              children: [
                _buildBaseSelector(
                  'From',
                  _fromBase,
                  (v) => setState(() => _fromBase = v!),
                  theme,
                ),
                const SizedBox(height: 16),
                Icon(Icons.arrow_downward, color: theme.primary, size: 28),
                const SizedBox(height: 16),
                _buildBaseSelector(
                  'To',
                  _toBase,
                  (v) => setState(() => _toBase = v!),
                  theme,
                ),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // Convert Button
          ElevatedButton(
            onPressed: _convert,
            style: ElevatedButton.styleFrom(
              backgroundColor: theme.primary,
              foregroundColor: theme.background,
              padding: const EdgeInsets.symmetric(vertical: 16),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.calculate, color: theme.background),
                const SizedBox(width: 8),
                Text(
                  'Convert',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: theme.background,
                  ),
                ),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // Result Section
          if (_error.isNotEmpty)
            ThemedCard(
              color: theme.error.withOpacity(0.1),
              child: Row(
                children: [
                  Icon(Icons.error_outline, color: theme.error),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      _error,
                      style: TextStyle(
                        fontSize: 16,
                        color: theme.error,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                ],
              ),
            ),

          if (_result.isNotEmpty)
            ThemedCard(
              color: theme.success.withOpacity(0.1),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(Icons.check_circle, color: theme.success),
                      const SizedBox(width: 8),
                      Text(
                        'Result',
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: theme.success,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: theme.panel,
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: theme.success, width: 2),
                    ),
                    child: SelectableText(
                      _result,
                      style: TextStyle(
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                        fontFamily: 'monospace',
                        color: theme.foreground,
                      ),
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    '${_baseNames[_toBase]} (Base $_toBase)',
                    style: TextStyle(fontSize: 14, color: theme.muted),
                  ),
                ],
              ),
            ),

          const SizedBox(height: 16),

          // Quick Reference
          ThemedCard(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Quick Reference',
                  style: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                    color: theme.muted,
                  ),
                ),
                const SizedBox(height: 8),
                _buildReferenceRow('Binary (Base 2)', '0-1', theme),
                _buildReferenceRow('Octal (Base 8)', '0-7', theme),
                _buildReferenceRow('Decimal (Base 10)', '0-9', theme),
                _buildReferenceRow('Hexadecimal (Base 16)', '0-9, A-F', theme),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildBaseSelector(
    String label,
    int value,
    Function(int?) onChanged,
    dynamic theme,
  ) {
    return Row(
      children: [
        SizedBox(
          width: 80,
          child: Text(
            label,
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w600,
              color: theme.foreground,
            ),
          ),
        ),
        Expanded(
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
            decoration: BoxDecoration(
              color: theme.panel,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: theme.subtle),
            ),
            child: DropdownButton<int>(
              value: value,
              isExpanded: true,
              underline: const SizedBox(),
              dropdownColor: theme.panel,
              style: TextStyle(fontSize: 16, color: theme.foreground),
              items: _bases.map((base) {
                return DropdownMenuItem(
                  value: base,
                  child: Text(
                    '${_baseNames[base]} ($base)',
                    style: TextStyle(color: theme.foreground),
                  ),
                );
              }).toList(),
              onChanged: onChanged,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildReferenceRow(String name, String digits, dynamic theme) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Expanded(
            child: Text(
              name,
              style: TextStyle(fontSize: 12, color: theme.muted),
            ),
          ),
          Text(
            digits,
            style: TextStyle(
              fontSize: 12,
              fontFamily: 'monospace',
              color: theme.muted,
            ),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _inputController.dispose();
    super.dispose();
  }
}
import 'package:app/services/calculator_service.dart';
import 'package:app/services/conversion_service.dart';
import 'package:app/services/function_service.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'scientific_calculator_page.dart';
import 'modulo_calculator_page.dart';
import 'matrix_calculator_page.dart';
import 'base_n_calculator_page.dart';
import 'conversion_page.dart';
import 'custom_functions_page.dart';
import '../state/calculator_state.dart';
import '../theme/theme_provider.dart';

class CalculatorHome extends StatefulWidget {
  final CalculatorService calculatorService;
  final FunctionService functionService;
  final ConversionService conversionService;

  const CalculatorHome({
    super.key,
    required this.calculatorService,
    required this.functionService,
    required this.conversionService,
  });

  @override
  State<CalculatorHome> createState() => _CalculatorHomeState();
}

class _CalculatorHomeState extends State<CalculatorHome> {
  int _selectedIndex = 0;

  @override
  Widget build(BuildContext context) {
    final theme = context.watch<ThemeProvider>().currentTheme;

    return MultiProvider(
      providers: [
        Provider<FunctionService>.value(value: widget.functionService),
        Provider<CalculatorService>.value(value: widget.calculatorService),

        ChangeNotifierProvider<ConversionService>.value(
          value: widget.conversionService,
        ),

        ChangeNotifierProvider(
          create: (_) =>
              CalculatorState(widget.calculatorService, widget.functionService),
        ),
      ],
      child: Scaffold(
        body: SafeArea(
          child: IndexedStack(index: _selectedIndex, children: _pages),
        ),
        backgroundColor: theme.surface,
        bottomNavigationBar: Container(
          decoration: BoxDecoration(
            color: theme.surface,
            boxShadow: [
              BoxShadow(
                color: Colors.black.withValues(alpha: 0.2),
                blurRadius: 8,
                offset: const Offset(0, -2),
              ),
            ],
          ),
          child: Padding(
            padding: const EdgeInsets.fromLTRB(8, 8, 8, 8),
            child: BottomNavigationBar(
              currentIndex: _selectedIndex,
              onTap: (i) => setState(() => _selectedIndex = i),
              backgroundColor: Colors.transparent,
              selectedItemColor: theme.primary,
              unselectedItemColor: theme.muted,
              selectedLabelStyle: const TextStyle(
                fontWeight: FontWeight.bold,
                fontSize: 12,
              ),
              unselectedLabelStyle: const TextStyle(fontSize: 12),
              type: BottomNavigationBarType.fixed,
              elevation: 0,
              items: [
                _buildNavItem(
                  icon: Icons.calculate,
                  label: 'Calculator',
                  isSelected: _selectedIndex == 0,
                  theme: theme,
                ),
                _buildNavItem(
                  icon: Icons.percent,
                  label: 'Modulo',
                  isSelected: _selectedIndex == 1,
                  theme: theme,
                ),
                _buildNavItem(
                  icon: Icons.grid_on,
                  label: 'Matrix',
                  isSelected: _selectedIndex == 2,
                  theme: theme,
                ),
                _buildNavItem(
                  icon: Icons.tag,
                  label: 'Base N',
                  isSelected: _selectedIndex == 3,
                  theme: theme,
                ),
                _buildNavItem(
                  icon: Icons.swap_horiz,
                  label: 'Convert',
                  isSelected: _selectedIndex == 4,
                  theme: theme,
                ),
                _buildNavItem(
                  icon: Icons.functions,
                  label: 'Functions',
                  isSelected: _selectedIndex == 5,
                  theme: theme,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  BottomNavigationBarItem _buildNavItem({
    required IconData icon,
    required String label,
    required bool isSelected,
    required dynamic theme,
  }) {
    return BottomNavigationBarItem(
      icon: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: isSelected
              ? theme.primary.withOpacity(0.15)
              : Colors.transparent,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Icon(
          icon,
          size: 24,
          color: isSelected ? theme.primary : theme.muted,
        ),
      ),
      label: label,
    );
  }

  List<Widget> get _pages => [
    const ScientificCalculatorPage(),
    const ModuloCalculatorPage(),
    const MatrixCalculatorPage(),
    const BaseNCalculatorPage(),
    const ConversionPage(),
    const CustomFunctionsPage(),
  ];
}
import 'package:app/models/unit_models.dart';
import 'package:app/services/conversion_service.dart';
import 'package:app/services/unit_data.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../widgets/app_page.dart';
import '../theme/theme_provider.dart';

class ConversionPage extends StatefulWidget {
  const ConversionPage({Key? key}) : super(key: key);

  @override
  State<ConversionPage> createState() => _ConversionPageState();
}

class _ConversionPageState extends State<ConversionPage> {
  @override
  Widget build(BuildContext context) {
    final service = context.watch<ConversionService>();
    final theme = context.watch<ThemeProvider>().currentTheme;

    return AppPage(
      title: 'Precision Converter',
      child: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _buildGroupedDropdown(service, theme),
            const SizedBox(height: 24),

            ThemedCard(
              padding: const EdgeInsets.all(20),
              child: Column(
                children: [
                  _buildInputRow(service, theme, isSource: true),
                  Padding(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    child: GestureDetector(
                      onTap: service.swap,
                      child: TweenAnimationBuilder<double>(
                        tween: Tween(begin: 0, end: 1),
                        duration: const Duration(milliseconds: 300),
                        builder: (_, v, child) {
                          return Transform.rotate(
                            angle: v * 3.1416,
                            child: child,
                          );
                        },
                        child: Icon(
                          Icons.swap_vert_circle,
                          color: theme.primary,
                          size: 32,
                        ),
                      ),
                    ),
                  ),
                  _buildInputRow(service, theme, isSource: false),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildGroupedDropdown(ConversionService service, dynamic theme) {
    // Logic to group UnitData.categories by domain for the UI
    return GestureDetector(
      onTap: () => _openCategoryPicker(context, service, theme),
      child: Container(
        decoration: BoxDecoration(
          color: theme.panel,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: theme.subtle),
        ),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        child: Row(
          children: [
            Icon(service.currentCategory.icon, color: theme.primary),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                service.currentCategory.name,
                style: TextStyle(color: theme.foreground),
              ),
            ),
            Icon(Icons.search, color: theme.muted),
          ],
        ),
      ),
    );
  }

  void _openCategoryPicker(
    BuildContext context,
    ConversionService service,
    dynamic theme,
  ) {
    showModalBottomSheet(
      context: context,
      backgroundColor: theme.surface,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (_) {
        String query = '';

        return StatefulBuilder(
          builder: (context, setState) {
            final filtered = UnitData.categories.where((c) {
              return c.name.toLowerCase().contains(query.toLowerCase()) ||
                  c.domain.toLowerCase().contains(query.toLowerCase());
            }).toList();

            return Padding(
              padding: EdgeInsets.fromLTRB(
                16,
                16,
                16,
                MediaQuery.of(context).viewInsets.bottom + 16,
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  // Search
                  TextField(
                    autofocus: true,
                    decoration: InputDecoration(
                      hintText: 'Search categories...',
                      prefixIcon: Icon(Icons.search, color: theme.muted),
                    ),
                    onChanged: (v) => setState(() => query = v),
                  ),
                  const SizedBox(height: 12),

                  // List
                  SizedBox(
                    height: 400,
                    child: ListView.builder(
                      itemCount: filtered.length,
                      itemBuilder: (_, i) {
                        final cat = filtered[i];
                        return ListTile(
                          leading: Icon(cat.icon, color: theme.primary),
                          title: Text(
                            cat.name,
                            style: TextStyle(color: theme.foreground),
                          ),
                          subtitle: Text(
                            cat.domain,
                            style: TextStyle(color: theme.muted),
                          ),
                          onTap: () {
                            service.setCategory(cat);
                            Navigator.pop(context);
                          },
                        );
                      },
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }

  // Visual Hierarchy: Headers are bold and smaller, items are indented
  List<DropdownMenuItem<CategoryDefinition>> _buildGroupedItems(dynamic theme) {
    List<DropdownMenuItem<CategoryDefinition>> items = [];
    String? lastDomain;

    for (var cat in UnitData.categories) {
      if (cat.domain != lastDomain) {
        items.add(
          DropdownMenuItem(
            enabled: false,
            child: Text(
              cat.domain.toUpperCase(),
              style: TextStyle(
                color: theme.primary,
                fontWeight: FontWeight.bold,
                fontSize: 11,
              ),
            ),
          ),
        );
        lastDomain = cat.domain;
      }
      items.add(
        DropdownMenuItem(
          value: cat,
          child: Row(
            children: [
              Icon(cat.icon, size: 18, color: theme.muted),
              SizedBox(width: 12),
              Text(cat.name, style: TextStyle(color: theme.foreground)),
            ],
          ),
        ),
      );
    }
    return items;
  }

  Widget _buildInputRow(
    ConversionService service,
    dynamic theme, {
    required bool isSource,
  }) {
    final currentUnit = isSource ? service.fromUnit : service.toUnit;

    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        // VALUE SECTION
        Expanded(
          flex: 3,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                isSource ? "From" : "To",
                style: TextStyle(
                  color: theme.muted,
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                  letterSpacing: 1.1,
                ),
              ),
              const SizedBox(height: 4),
              isSource
                  ? TextField(
                      controller: service.inputController
                        ..selection = TextSelection.collapsed(
                          offset: service.input.length,
                        ),
                      onChanged: service.convert,
                      keyboardType: const TextInputType.numberWithOptions(
                        decimal: true,
                      ),
                      style: TextStyle(
                        fontSize: 28,
                        fontWeight: FontWeight.bold,
                        color: theme.foreground,
                      ),
                      decoration: InputDecoration(
                        hintText: "0.00",
                        hintStyle: TextStyle(color: theme.subtle),
                        border: InputBorder.none,
                        isDense: true,
                        contentPadding: EdgeInsets.zero,
                      ),
                    )
                  : AnimatedSwitcher(
                      duration: const Duration(milliseconds: 250),
                      transitionBuilder: (child, anim) =>
                          FadeTransition(opacity: anim, child: child),
                      child: Text(
                        service.output.isEmpty ? "0.00" : service.output,
                        key: ValueKey(service.output),
                        style: TextStyle(
                          fontSize: 28,
                          fontWeight: FontWeight.bold,
                          color: service.output.isEmpty
                              ? theme.subtle
                              : theme.primary,
                        ),
                      ),
                    ),
            ],
          ),
        ),

        // UNIT SELECTOR SECTION
        const SizedBox(width: 12),
        Container(
          height: 45,
          padding: const EdgeInsets.symmetric(horizontal: 12),
          decoration: BoxDecoration(
            color: theme.panel,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: theme.subtle.withOpacity(0.5)),
          ),
          child: DropdownButtonHideUnderline(
            child: DropdownButton<UnitDefinition>(
              value: currentUnit,
              menuMaxHeight: 220,
              icon: Icon(Icons.unfold_more, size: 18, color: theme.primary),
              dropdownColor: theme.panel,
              items: service.currentCategory.units.map((unit) {
                return DropdownMenuItem(
                  value: unit,
                  child: Text(
                    unit.symbol,
                    style: TextStyle(
                      color: theme.foreground,
                      fontWeight: FontWeight.w600,
                      fontSize: 16,
                    ),
                  ),
                );
              }).toList(),
              onChanged: (newUnit) {
                if (isSource) {
                  service.updateUnits(from: newUnit);
                } else {
                  service.updateUnits(to: newUnit);
                }
              },
            ),
          ),
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/custom_function.dart';
import '../services/function_service.dart';
import '../widgets/function_test_dialog.dart';
import '../widgets/app_page.dart';
import '../theme/theme_provider.dart';

class CustomFunctionsPage extends StatefulWidget {
  const CustomFunctionsPage({Key? key}) : super(key: key);

  @override
  State<CustomFunctionsPage> createState() => _CustomFunctionsPageState();
}

class _CustomFunctionsPageState extends State<CustomFunctionsPage> {
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _formulaController = TextEditingController();
  final TextEditingController _paramController = TextEditingController();
  final List<String> _parameters = [];

  void _addParameter() {
    if (_paramController.text.isNotEmpty) {
      setState(() {
        _parameters.add(_paramController.text);
        _paramController.clear();
      });
    }
  }

  void _saveFunction() {
    if (_nameController.text.isEmpty ||
        _formulaController.text.isEmpty ||
        _parameters.isEmpty) {
      _showError('Please fill all fields and add at least one parameter');
      return;
    }

    final functionService = context.read<FunctionService>();

    final newFunc = CustomFunction(
      name: _nameController.text,
      parameters: List.from(_parameters),
      formula: _formulaController.text,
    );

    final updated = [...functionService.currentFunctions, newFunc];
    functionService.setFunctions(updated);

    setState(() {
      _nameController.clear();
      _formulaController.clear();
      _parameters.clear();
    });

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: const Text('Function saved successfully!'),
        backgroundColor: context.read<ThemeProvider>().currentTheme.success,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  void _deleteFunction(int index) {
    final theme = context.read<ThemeProvider>().currentTheme;

    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Delete Function'),
        content: const Text('Are you sure you want to delete this function?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              final functionService = context.read<FunctionService>();
              final updated = List<CustomFunction>.from(
                functionService.currentFunctions,
              )..removeAt(index);

              functionService.setFunctions(updated);
              setState(() {});
              Navigator.pop(ctx);
            },
            style: TextButton.styleFrom(foregroundColor: theme.error),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  void _testFunction(CustomFunction func) {
    showDialog(
      context: context,
      builder: (_) => FunctionTestDialog(function: func),
    );
  }

  void _showError(String message) {
    final theme = context.read<ThemeProvider>().currentTheme;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: theme.error,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final functionService = context.watch<FunctionService>();
    final functions = functionService.currentFunctions;
    final theme = context.watch<ThemeProvider>().currentTheme;

    return AppPage(
      title: 'Custom Functions',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Create Function Section
          ThemedCard(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(Icons.add_circle, color: theme.primary),
                    const SizedBox(width: 8),
                    Text(
                      'Create New Function',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: theme.primary,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),

                // Function Name
                TextField(
                  controller: _nameController,
                  style: TextStyle(color: theme.foreground),
                  decoration: InputDecoration(
                    labelText: 'Function Name',
                    hintText: 'e.g., myFunc',
                    prefixIcon: Icon(Icons.functions, color: theme.primary),
                  ),
                ),

                const SizedBox(height: 12),

                // Parameters
                Row(
                  children: [
                    Expanded(
                      child: TextField(
                        controller: _paramController,
                        style: TextStyle(color: theme.foreground),
                        decoration: InputDecoration(
                          labelText: 'Parameter',
                          hintText: 'e.g., x',
                          prefixIcon: Icon(Icons.input, color: theme.primary),
                        ),
                        onSubmitted: (_) => _addParameter(),
                      ),
                    ),
                    const SizedBox(width: 8),
                    ElevatedButton(
                      onPressed: _addParameter,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: theme.primary,
                        foregroundColor: theme.background,
                        padding: const EdgeInsets.symmetric(
                          horizontal: 20,
                          vertical: 16,
                        ),
                      ),
                      child: const Text('Add'),
                    ),
                  ],
                ),

                const SizedBox(height: 8),

                // Parameter Chips
                if (_parameters.isNotEmpty)
                  Wrap(
                    spacing: 8,
                    runSpacing: 8,
                    children: _parameters.map((p) {
                      return Chip(
                        label: Text(p),
                        backgroundColor: theme.primary.withOpacity(0.2),
                        deleteIconColor: theme.primary,
                        side: BorderSide(color: theme.primary),
                        onDeleted: () {
                          setState(() => _parameters.remove(p));
                        },
                      );
                    }).toList(),
                  ),

                const SizedBox(height: 12),

                // Formula
                TextField(
                  controller: _formulaController,
                  maxLines: 3,
                  style: TextStyle(
                    fontFamily: 'monospace',
                    color: theme.foreground,
                  ),
                  decoration: InputDecoration(
                    labelText: 'Formula',
                    hintText: 'e.g., x^2 + 2*x + 1',
                    prefixIcon: Icon(Icons.code, color: theme.primary),
                    alignLabelWithHint: true,
                  ),
                ),

                const SizedBox(height: 16),

                // Save Button
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: _saveFunction,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: theme.success,
                      foregroundColor: theme.background,
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.save, color: theme.background),
                        const SizedBox(width: 8),
                        Text(
                          'Save Function',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                            color: theme.background,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),

          const SizedBox(height: 24),

          // Saved Functions Section
          Text(
            'Saved Functions (${functions.length})',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
              color: theme.foreground,
            ),
          ),

          const SizedBox(height: 12),

          if (functions.isEmpty)
            ThemedCard(
              child: Column(
                children: [
                  Icon(Icons.functions, size: 64, color: theme.muted),
                  const SizedBox(height: 16),
                  Text(
                    'No custom functions yet',
                    style: TextStyle(fontSize: 16, color: theme.muted),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Create your first function above!',
                    style: TextStyle(fontSize: 14, color: theme.muted),
                  ),
                ],
              ),
            )
          else
            ...functions.asMap().entries.map((entry) {
              final i = entry.key;
              final f = entry.value;

              return Padding(
                padding: const EdgeInsets.only(bottom: 12),
                child: ThemedCard(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Container(
                            padding: const EdgeInsets.all(8),
                            decoration: BoxDecoration(
                              color: theme.primary.withOpacity(0.2),
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Icon(
                              Icons.functions,
                              color: theme.primary,
                              size: 24,
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  '${f.name}(${f.parameters.join(', ')})',
                                  style: TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.bold,
                                    color: theme.foreground,
                                  ),
                                ),
                                const SizedBox(height: 4),
                                Text(
                                  f.formula,
                                  style: TextStyle(
                                    fontSize: 14,
                                    fontFamily: 'monospace',
                                    color: theme.muted,
                                  ),
                                  maxLines: 2,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      Row(
                        children: [
                          Expanded(
                            child: OutlinedButton.icon(
                              onPressed: () => _testFunction(f),
                              icon: Icon(
                                Icons.play_arrow,
                                color: theme.success,
                              ),
                              label: Text(
                                'Test',
                                style: TextStyle(color: theme.success),
                              ),
                              style: OutlinedButton.styleFrom(
                                side: BorderSide(color: theme.success),
                              ),
                            ),
                          ),
                          const SizedBox(width: 8),
                          OutlinedButton.icon(
                            onPressed: () => _deleteFunction(i),
                            icon: Icon(Icons.delete, color: theme.error),
                            label: Text(
                              'Delete',
                              style: TextStyle(color: theme.error),
                            ),
                            style: OutlinedButton.styleFrom(
                              side: BorderSide(color: theme.error),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              );
            }),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _nameController.dispose();
    _formulaController.dispose();
    _paramController.dispose();
    super.dispose();
  }
}
import 'dart:math';
import 'package:app/theme/theme_data.dart';
import 'package:app/theme/theme_provider.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

class EquationPage extends StatefulWidget {
  const EquationPage({Key? key}) : super(key: key);

  @override
  State<EquationPage> createState() => _EquationPageState();
}

class _EquationPageState extends State<EquationPage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  int _polyDegree = 2;
  final List<TextEditingController> _polyCoeffs = List.generate(
    4,
    (_) => TextEditingController(),
  );
  String _polyResult = '';

  int _sysUnknowns = 2;
  final List<List<TextEditingController>> _sysCoeffs = List.generate(
    3,
    (_) => List.generate(4, (_) => TextEditingController()),
  );
  String _sysResult = '';

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    for (var ctrl in _polyCoeffs) {
      ctrl.dispose();
    }
    for (var row in _sysCoeffs) {
      for (var ctrl in row) {
        ctrl.dispose();
      }
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = context.watch<ThemeProvider>().currentTheme;

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        title: const Text('Equation Solver'),
        backgroundColor: theme.surface,
        foregroundColor: theme.foreground,
        elevation: 0,
        bottom: TabBar(
          controller: _tabController,
          indicatorColor: theme.primary,
          labelColor: theme.primary,
          unselectedLabelColor: theme.muted,
          indicatorWeight: 3,
          tabs: const [
            Tab(icon: Icon(Icons.functions), text: 'Polynomial'),
            Tab(icon: Icon(Icons.grid_3x3), text: 'Simultaneous'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [_buildPolynomialTab(theme), _buildSystemTab(theme)],
      ),
    );
  }

  Widget _buildPolynomialTab(AppThemeData theme) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Polynomial Equation',
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
              color: theme.foreground,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Solve equations of degree 2 or 3',
            style: TextStyle(color: theme.muted, fontSize: 14),
          ),
          const SizedBox(height: 24),

          // Degree selector
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: theme.surface,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: theme.subtle),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(
                  'Degree',
                  style: TextStyle(
                    color: theme.muted,
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                SegmentedButton<int>(
                  segments: const [
                    ButtonSegment(value: 2, label: Text('Quadratic (2)')),
                    ButtonSegment(value: 3, label: Text('Cubic (3)')),
                  ],
                  selected: {_polyDegree},
                  onSelectionChanged: (Set<int> selection) {
                    setState(() {
                      _polyDegree = selection.first;
                      _polyResult = '';
                    });
                  },
                  style: SegmentedButton.styleFrom(
                    selectedBackgroundColor: theme.primary,
                    selectedForegroundColor: theme.background,
                    fixedSize: const Size(double.infinity, 40),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 24),

          // Equation display
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: theme.surface,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: theme.subtle),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Coefficients',
                  style: TextStyle(
                    color: theme.muted,
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 16),
                _buildPolynomialInput(theme),
              ],
            ),
          ),
          const SizedBox(height: 24),

          // Solve button
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.primary,
                foregroundColor: theme.background,
                padding: const EdgeInsets.symmetric(vertical: 16),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                elevation: 2,
              ),
              onPressed: _solvePolynomial,
              child: const Text(
                'SOLVE',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                  letterSpacing: 1,
                ),
              ),
            ),
          ),

          if (_polyResult.isNotEmpty) ...[
            const SizedBox(height: 24),
            _buildResultCard(theme, _polyResult),
          ],
        ],
      ),
    );
  }

  Widget _buildPolynomialInput(AppThemeData theme) {
    List<Widget> terms = [];

    for (int i = 0; i <= _polyDegree; i++) {
      if (i > 0) {
        terms.add(
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: Text(
              '+',
              style: TextStyle(
                color: theme.muted,
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        );
      }

      terms.add(
        Expanded(
          child: TextField(
            controller: _polyCoeffs[i],
            keyboardType: const TextInputType.numberWithOptions(
              decimal: true,
              signed: true,
            ),
            textAlign: TextAlign.center,
            style: TextStyle(
              color: theme.foreground,
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
            decoration: InputDecoration(
              labelText: String.fromCharCode('a'.codeUnitAt(0) + i),
              labelStyle: TextStyle(color: theme.primary),
              filled: true,
              fillColor: theme.background,
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              contentPadding: const EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 14,
              ),
            ),
          ),
        ),
      );

      String power = switch (_polyDegree - i) {
        0 => '',
        1 => 'x',
        2 => 'x²',
        3 => 'x³',
        _ => '',
      };
      terms.add(
        Padding(
          padding: const EdgeInsets.only(left: 4),
          child: Text(
            power,
            style: TextStyle(
              color: theme.primary,
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      );
    }

    terms.add(
      Padding(
        padding: const EdgeInsets.only(left: 8),
        child: Text(
          '= 0',
          style: TextStyle(
            color: theme.foreground,
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );

    return Row(crossAxisAlignment: CrossAxisAlignment.center, children: terms);
  }

  void _solvePolynomial() {
    if (_polyDegree == 2) {
      double a = double.tryParse(_polyCoeffs[0].text) ?? 0;
      double b = double.tryParse(_polyCoeffs[1].text) ?? 0;
      double c = double.tryParse(_polyCoeffs[2].text) ?? 0;

      if (a == 0) {
        setState(() => _polyResult = 'Error: Not a quadratic equation (a = 0)');
        return;
      }

      double discriminant = b * b - 4 * a * c;

      if (discriminant > 0) {
        double x1 = (-b + sqrt(discriminant)) / (2 * a);
        double x2 = (-b - sqrt(discriminant)) / (2 * a);
        setState(
          () => _polyResult =
              'Two real solutions:\n\nx₁ = ${_formatNum(x1)}\nx₂ = ${_formatNum(x2)}',
        );
      } else if (discriminant == 0) {
        double x = -b / (2 * a);
        setState(
          () => _polyResult = 'One repeated solution:\n\nx = ${_formatNum(x)}',
        );
      } else {
        double real = -b / (2 * a);
        double imag = sqrt(-discriminant) / (2 * a);
        setState(
          () => _polyResult =
              'Two complex solutions:\n\nx₁ = ${_formatNum(real)} + ${_formatNum(imag)}i\nx₂ = ${_formatNum(real)} - ${_formatNum(imag)}i',
        );
      }
    } else if (_polyDegree == 3) {
      setState(
        () => _polyResult =
            'Cubic equation solver:\n\nComing soon! This requires Cardano\'s formula implementation.',
      );
    }
  }

  Widget _buildSystemTab(AppThemeData theme) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'System of Linear Equations',
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
              color: theme.foreground,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Solve simultaneous equations',
            style: TextStyle(color: theme.muted, fontSize: 14),
          ),
          const SizedBox(height: 24),

          // Unknowns selector
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: theme.surface,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: theme.subtle),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(
                  'Number of Unknowns',
                  style: TextStyle(
                    color: theme.muted,
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                SegmentedButton<int>(
                  segments: const [
                    ButtonSegment(value: 2, label: Text('2 (x, y)')),
                    ButtonSegment(value: 3, label: Text('3 (x, y, z)')),
                  ],
                  selected: {_sysUnknowns},
                  onSelectionChanged: (Set<int> selection) {
                    setState(() {
                      _sysUnknowns = selection.first;
                      _sysResult = '';
                    });
                  },
                  style: SegmentedButton.styleFrom(
                    selectedBackgroundColor: theme.primary,
                    selectedForegroundColor: theme.background,
                    fixedSize: const Size(double.infinity, 40),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 24),

          // Equations
          ...List.generate(_sysUnknowns, (row) {
            return Padding(
              padding: const EdgeInsets.only(bottom: 16),
              child: _buildSystemRow(theme, row),
            );
          }),

          const SizedBox(height: 8),

          // Solve button
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.primary,
                foregroundColor: theme.background,
                padding: const EdgeInsets.symmetric(vertical: 16),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              onPressed: _solveSystem,
              child: const Text(
                'SOLVE',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                  letterSpacing: 1,
                ),
              ),
            ),
          ),

          if (_sysResult.isNotEmpty) ...[
            const SizedBox(height: 24),
            _buildResultCard(theme, _sysResult),
          ],
        ],
      ),
    );
  }

  Widget _buildSystemRow(AppThemeData theme, int row) {
    const vars = ['x', 'y', 'z'];

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.subtle),
      ),
      child: Row(
        children: [
          for (int col = 0; col < _sysUnknowns; col++) ...[
            if (col > 0)
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
                child: Text(
                  '+',
                  style: TextStyle(color: theme.muted, fontSize: 18),
                ),
              ),
            Expanded(
              child: TextField(
                controller: _sysCoeffs[row][col],
                keyboardType: const TextInputType.numberWithOptions(
                  decimal: true,
                  signed: true,
                ),
                textAlign: TextAlign.center,
                style: TextStyle(color: theme.foreground, fontSize: 16),
                decoration: InputDecoration(
                  filled: true,
                  fillColor: theme.background,
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 12,
                  ),
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.only(left: 4),
              child: Text(
                vars[col],
                style: TextStyle(
                  color: theme.primary,
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ],
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: Text(
              '=',
              style: TextStyle(color: theme.foreground, fontSize: 18),
            ),
          ),
          SizedBox(
            width: 80,
            child: TextField(
              controller: _sysCoeffs[row][_sysUnknowns],
              keyboardType: const TextInputType.numberWithOptions(
                decimal: true,
                signed: true,
              ),
              textAlign: TextAlign.center,
              style: TextStyle(color: theme.foreground, fontSize: 16),
              decoration: InputDecoration(
                filled: true,
                fillColor: theme.background,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
                contentPadding: const EdgeInsets.symmetric(
                  horizontal: 8,
                  vertical: 12,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _solveSystem() {
    if (_sysUnknowns == 2) {
      double a1 = double.tryParse(_sysCoeffs[0][0].text) ?? 0;
      double b1 = double.tryParse(_sysCoeffs[0][1].text) ?? 0;
      double c1 = double.tryParse(_sysCoeffs[0][2].text) ?? 0;

      double a2 = double.tryParse(_sysCoeffs[1][0].text) ?? 0;
      double b2 = double.tryParse(_sysCoeffs[1][1].text) ?? 0;
      double c2 = double.tryParse(_sysCoeffs[1][2].text) ?? 0;

      double det = a1 * b2 - a2 * b1;

      if (det == 0) {
        setState(() => _sysResult = 'No unique solution\n(Determinant = 0)');
      } else {
        double dx = c1 * b2 - c2 * b1;
        double dy = a1 * c2 - a2 * c1;
        double x = dx / det;
        double y = dy / det;
        setState(
          () => _sysResult =
              'Solution:\n\nx = ${_formatNum(x)}\ny = ${_formatNum(y)}',
        );
      }
    } else {
      setState(
        () => _sysResult =
            '3×3 system solver:\n\nComing soon! This requires Gaussian elimination.',
      );
    }
  }

  Widget _buildResultCard(AppThemeData theme, String result) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: theme.primary.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.primary.withOpacity(0.3), width: 2),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.check_circle, color: theme.primary, size: 24),
              const SizedBox(width: 8),
              Text(
                'Solution',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: theme.primary,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Text(
            result,
            style: TextStyle(
              color: theme.foreground,
              fontSize: 16,
              height: 1.6,
              fontFamily: 'monospace',
            ),
          ),
        ],
      ),
    );
  }

  String _formatNum(double val) {
    if (val.abs() >= 1000000 || (val.abs() < 0.0001 && val != 0)) {
      return val.toStringAsExponential(6);
    }
    return val.toStringAsFixed(8).replaceFirst(RegExp(r'\.?0+$'), '');
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../widgets/app_page.dart';
import '../utils/matrix_operations.dart';
import '../theme/theme_provider.dart';

class MatrixCalculatorPage extends StatefulWidget {
  const MatrixCalculatorPage({Key? key}) : super(key: key);

  @override
  State<MatrixCalculatorPage> createState() => _MatrixCalculatorPageState();
}

class _MatrixCalculatorPageState extends State<MatrixCalculatorPage> {
  static List<int> sizes = [2, 3, 4, 5, 6, 7, 8, 9, 10];
  static int defaultSize = 3;
  int rows1 = defaultSize, cols1 = defaultSize;
  int rows2 = defaultSize, cols2 = defaultSize;
  List<List<double>> matrix1 = [
    [0, 0],
    [0, 0],
  ];
  List<List<double>> matrix2 = [
    [0, 0],
    [0, 0],
  ];
  String result = '';
  String _operation = '';

  void _resizeMatrix1() {
    setState(() {
      matrix1 = List.generate(rows1, (i) => List.filled(cols1, 0.0));
    });
  }

  void _resizeMatrix2() {
    setState(() {
      matrix2 = List.generate(rows2, (i) => List.filled(cols2, 0.0));
    });
  }

  void _calculate(String operation) {
    setState(() {
      _operation = operation;
    });

    try {
      switch (operation) {
        case 'add':
          final resultMatrix = MatrixOperations.add(matrix1, matrix2);
          setState(() {
            result = MatrixOperations.formatMatrix(resultMatrix);
          });
          break;
        case 'multiply':
          final resultMatrix = MatrixOperations.multiply(matrix1, matrix2);
          setState(() {
            result = MatrixOperations.formatMatrix(resultMatrix);
          });
          break;
        case 'det':
          final det = MatrixOperations.determinant(matrix1);
          setState(() {
            result = 'Determinant: ${det.toStringAsFixed(4)}';
          });
          break;
        case 'transpose':
          final resultMatrix = MatrixOperations.transpose(matrix1);
          setState(() {
            result = MatrixOperations.formatMatrix(resultMatrix);
          });
          break;
      }
    } catch (e) {
      setState(() {
        result = 'Error: ${e.toString().replaceAll('Exception: ', '')}';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = context.watch<ThemeProvider>().currentTheme;

    return AppPage(
      title: 'Matrix Calculator',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Matrix 1
          ThemedCard(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Matrix A',
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: theme.primary,
                      ),
                    ),
                    Row(
                      children: [
                        Text('Size:', style: TextStyle(color: theme.muted)),
                        const SizedBox(width: 8),
                        _buildSizeDropdown(rows1, (v) {
                          setState(() {
                            rows1 = v!;
                            _resizeMatrix1();
                          });
                        }, theme),
                        const SizedBox(width: 4),
                        Text('×', style: TextStyle(color: theme.muted)),
                        const SizedBox(width: 4),
                        _buildSizeDropdown(cols1, (v) {
                          setState(() {
                            cols1 = v!;
                            _resizeMatrix1();
                          });
                        }, theme),
                      ],
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                _buildMatrixInput(matrix1, rows1, cols1, theme),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // Matrix 2
          ThemedCard(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Matrix B',
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: theme.secondary,
                      ),
                    ),
                    Row(
                      children: [
                        Text('Size:', style: TextStyle(color: theme.muted)),
                        const SizedBox(width: 8),
                        _buildSizeDropdown(rows2, (v) {
                          setState(() {
                            rows2 = v!;
                            _resizeMatrix2();
                          });
                        }, theme),
                        const SizedBox(width: 4),
                        Text('×', style: TextStyle(color: theme.muted)),
                        const SizedBox(width: 4),
                        _buildSizeDropdown(cols2, (v) {
                          setState(() {
                            cols2 = v!;
                            _resizeMatrix2();
                          });
                        }, theme),
                      ],
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                _buildMatrixInput(matrix2, rows2, cols2, theme),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // Operations
          ThemedCard(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Operations',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: theme.primary,
                  ),
                ),
                const SizedBox(height: 12),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    _buildOpButton(
                      'A + B',
                      'add',
                      Icons.add,
                      theme.success,
                      theme,
                    ),
                    _buildOpButton(
                      'A × B',
                      'multiply',
                      Icons.close,
                      theme.primary,
                      theme,
                    ),
                    _buildOpButton(
                      'det(A)',
                      'det',
                      Icons.calculate,
                      theme.accent,
                      theme,
                    ),
                    _buildOpButton(
                      'A^T',
                      'transpose',
                      Icons.swap_calls,
                      theme.secondary,
                      theme,
                    ),
                  ],
                ),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // Result
          if (result.isNotEmpty)
            ThemedCard(
              color: result.startsWith('Error')
                  ? theme.error.withOpacity(0.1)
                  : theme.success.withOpacity(0.1),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(
                        result.startsWith('Error')
                            ? Icons.error_outline
                            : Icons.check_circle,
                        color: result.startsWith('Error')
                            ? theme.error
                            : theme.success,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        result.startsWith('Error') ? 'Error' : 'Result',
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: result.startsWith('Error')
                              ? theme.error
                              : theme.success,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: theme.panel,
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(
                        color: result.startsWith('Error')
                            ? theme.error
                            : theme.success,
                        width: 2,
                      ),
                    ),
                    child: SelectableText(
                      result,
                      style: TextStyle(
                        fontSize: result.contains('[') ? 16 : 24,
                        fontWeight: FontWeight.bold,
                        fontFamily: 'monospace',
                        color: theme.foreground,
                      ),
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildSizeDropdown(
    int value,
    Function(int?) onChanged,
    dynamic theme,
  ) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      decoration: BoxDecoration(
        color: theme.panel,
        borderRadius: BorderRadius.circular(6),
        border: Border.all(color: theme.subtle),
      ),
      child: DropdownButton<int>(
        value: value,
        underline: const SizedBox(),
        dropdownColor: theme.panel,
        style: TextStyle(fontSize: 14, color: theme.foreground),
        items: sizes.map((i) {
          return DropdownMenuItem(
            value: i,
            child: Text('$i', style: TextStyle(color: theme.foreground)),
          );
        }).toList(),
        onChanged: onChanged,
      ),
    );
  }

  Widget _buildMatrixInput(
    List<List<double>> matrix,
    int rows,
    int cols,
    dynamic theme,
  ) {
    return Column(
      children: List.generate(
        rows,
        (i) => Padding(
          padding: const EdgeInsets.only(bottom: 6),
          child: Row(
            children: List.generate(
              cols,
              (j) => Expanded(
                child: Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 3),
                  child: Container(
                    decoration: BoxDecoration(
                      color: theme.panel,
                      borderRadius: BorderRadius.circular(6),
                      border: Border.all(color: theme.subtle),
                    ),
                    child: TextField(
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: theme.foreground,
                      ),
                      decoration: const InputDecoration(
                        border: InputBorder.none,
                        contentPadding: EdgeInsets.symmetric(vertical: 10),
                        hintText: '0',
                      ),
                      keyboardType: const TextInputType.numberWithOptions(
                        decimal: true,
                        signed: true,
                      ),
                      onChanged: (v) {
                        final value = double.tryParse(v) ?? 0;
                        setState(() {
                          matrix[i][j] = value;
                        });
                      },
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildOpButton(
    String label,
    String op,
    IconData icon,
    Color color,
    dynamic theme,
  ) {
    final isSelected = _operation == op && result.isNotEmpty;

    return InkWell(
      onTap: () => _calculate(op),
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: isSelected ? color.withOpacity(0.2) : theme.panel,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isSelected ? color : theme.subtle,
            width: isSelected ? 2 : 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: color, size: 20),
            const SizedBox(width: 8),
            Text(
              label,
              style: TextStyle(
                fontSize: 14,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                color: theme.foreground,
              ),
            ),
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../utils/modulo_operations.dart';
import '../widgets/app_page.dart';
import '../theme/theme_provider.dart';

class ModuloCalculatorPage extends StatefulWidget {
  const ModuloCalculatorPage({Key? key}) : super(key: key);

  @override
  State<ModuloCalculatorPage> createState() => _ModuloCalculatorPageState();
}

class _ModuloCalculatorPageState extends State<ModuloCalculatorPage> {
  final TextEditingController _aController = TextEditingController();
  final TextEditingController _bController = TextEditingController();
  final TextEditingController _modController = TextEditingController();
  String _result = '';
  String _operation = '';
  String _error = '';

  void _calculate(String operation) {
    setState(() {
      _error = '';
      _result = '';
      _operation = operation;
    });

    try {
      final a = int.parse(_aController.text);
      final b = int.parse(_bController.text);
      final mod = int.parse(_modController.text);

      int result;
      switch (operation) {
        case 'add':
          result = ModuloOperations.add(a, b, mod);
          break;
        case 'sub':
          result = ModuloOperations.subtract(a, b, mod);
          break;
        case 'mul':
          result = ModuloOperations.multiply(a, b, mod);
          break;
        case 'pow':
          result = ModuloOperations.power(a, b, mod);
          break;
        case 'inv':
          result = ModuloOperations.inverse(a, mod);
          break;
        default:
          result = 0;
      }

      setState(() {
        _result = result.toString();
      });
    } catch (e) {
      setState(() {
        _error = e.toString().replaceAll('Exception: ', '');
        _result = '';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = context.watch<ThemeProvider>().currentTheme;

    return AppPage(
      title: 'Modular Arithmetic',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Input Fields
          ThemedCard(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Inputs',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: theme.primary,
                  ),
                ),
                const SizedBox(height: 16),
                _buildNumberInput(
                  'Number A',
                  _aController,
                  'First operand',
                  Icons.looks_one,
                  theme,
                ),
                const SizedBox(height: 12),
                _buildNumberInput(
                  'Number B',
                  _bController,
                  'Second operand (or exponent)',
                  Icons.looks_two,
                  theme,
                ),
                const SizedBox(height: 12),
                _buildNumberInput(
                  'Modulo M',
                  _modController,
                  'Modulus value',
                  Icons.percent,
                  theme,
                ),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // Operations
          ThemedCard(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Operations',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: theme.primary,
                  ),
                ),
                const SizedBox(height: 12),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    _buildOperationButton(
                      '(A + B) mod M',
                      'add',
                      Icons.add,
                      theme.success,
                      theme,
                    ),
                    _buildOperationButton(
                      '(A − B) mod M',
                      'sub',
                      Icons.remove,
                      theme.warning,
                      theme,
                    ),
                    _buildOperationButton(
                      '(A × B) mod M',
                      'mul',
                      Icons.close,
                      theme.primary,
                      theme,
                    ),
                    _buildOperationButton(
                      'A^B mod M',
                      'pow',
                      Icons.functions,
                      theme.accent,
                      theme,
                    ),
                    _buildOperationButton(
                      'A^(-1) mod M',
                      'inv',
                      Icons.swap_horiz,
                      theme.secondary,
                      theme,
                    ),
                  ],
                ),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // Result or Error
          if (_error.isNotEmpty)
            ThemedCard(
              color: theme.error.withOpacity(0.1),
              child: Row(
                children: [
                  Icon(Icons.error_outline, color: theme.error, size: 32),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Error',
                          style: TextStyle(
                            fontSize: 14,
                            fontWeight: FontWeight.bold,
                            color: theme.error,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          _error,
                          style: TextStyle(fontSize: 14, color: theme.error),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),

          if (_result.isNotEmpty)
            ThemedCard(
              color: theme.success.withOpacity(0.1),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(Icons.check_circle, color: theme.success),
                      const SizedBox(width: 8),
                      Text(
                        'Result',
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: theme.success,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(20),
                    decoration: BoxDecoration(
                      color: theme.panel,
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(color: theme.success, width: 2),
                    ),
                    child: SelectableText(
                      _result,
                      style: TextStyle(
                        fontSize: 42,
                        fontWeight: FontWeight.bold,
                        fontFamily: 'monospace',
                        color: theme.foreground,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ),
                  const SizedBox(height: 12),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: theme.panel,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      _getOperationDescription(),
                      style: TextStyle(fontSize: 14, color: theme.muted),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ],
              ),
            ),

          const SizedBox(height: 16),

          // Info Card
          ThemedCard(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(Icons.info_outline, color: theme.primary, size: 20),
                    const SizedBox(width: 8),
                    Text(
                      'About Modular Arithmetic',
                      style: TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.bold,
                        color: theme.primary,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Text(
                  'Modular arithmetic is a system where numbers "wrap around" upon reaching a certain value (the modulus). It\'s used in cryptography, computer science, and number theory.',
                  style: TextStyle(
                    fontSize: 12,
                    color: theme.muted,
                    height: 1.5,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildNumberInput(
    String label,
    TextEditingController controller,
    String hint,
    IconData icon,
    dynamic theme,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            color: theme.foreground,
          ),
        ),
        const SizedBox(height: 6),
        TextField(
          controller: controller,
          keyboardType: TextInputType.number,
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            color: theme.foreground,
          ),
          decoration: InputDecoration(
            hintText: hint,
            prefixIcon: Icon(icon, color: theme.primary),
          ),
        ),
      ],
    );
  }

  Widget _buildOperationButton(
    String label,
    String op,
    IconData icon,
    Color color,
    dynamic theme,
  ) {
    final isSelected = _operation == op && _result.isNotEmpty;

    return InkWell(
      onTap: () => _calculate(op),
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: isSelected ? color.withOpacity(0.2) : theme.panel,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isSelected ? color : theme.subtle,
            width: isSelected ? 2 : 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: color, size: 20),
            const SizedBox(width: 8),
            Text(
              label,
              style: TextStyle(
                fontSize: 14,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                color: theme.foreground,
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _getOperationDescription() {
    if (_aController.text.isEmpty || _modController.text.isEmpty) {
      return '';
    }

    final a = _aController.text;
    final b = _bController.text;
    final m = _modController.text;

    switch (_operation) {
      case 'add':
        return '($a + $b) mod $m = $_result';
      case 'sub':
        return '($a − $b) mod $m = $_result';
      case 'mul':
        return '($a × $b) mod $m = $_result';
      case 'pow':
        return '$a^$b mod $m = $_result';
      case 'inv':
        return '$a^(-1) mod $m = $_result';
      default:
        return '';
    }
  }

  @override
  void dispose() {
    _aController.dispose();
    _bController.dispose();
    _modController.dispose();
    super.dispose();
  }
}
import 'package:app/core/eval_context.dart';
import 'package:app/pages/table_page.dart';
import 'package:app/pages/vector_page.dart';
import 'package:app/theme/theme_data.dart';
import 'package:app/widgets/theme_settings.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import '../state/calculator_state.dart';
import '../theme/theme_provider.dart';
import 'equation_page.dart';
import 'statistics_page.dart';

class ScientificCalculatorPage extends StatefulWidget {
  const ScientificCalculatorPage({super.key});

  @override
  State<ScientificCalculatorPage> createState() =>
      _ScientificCalculatorPageState();
}

class _ScientificCalculatorPageState extends State<ScientificCalculatorPage> {
  // Keep focus node to ensure cursor stays visible/blinking
  final FocusNode _inputFocusNode = FocusNode();

  @override
  void dispose() {
    _inputFocusNode.dispose();
    super.dispose();
  }

  void _handlePress(String primary, String? shift, String? alpha) {
    final state = context.read<CalculatorState>();

    // Request focus so the cursor is visible when typing
    if (!_inputFocusNode.hasFocus) {
      _inputFocusNode.requestFocus();
    }

    // Check if SHIFT is active and shift parameter contains STAT/EQN
    if (state.isShift && shift == 'STAT') {
      _navigateToStats();
      state.clearShift();
      return;
    }

    if (state.isShift && shift == 'EQN') {
      _navigateToEquation();
      state.clearShift();
      return;
    }

    if (state.isShift && shift == 'TABL') {
      _navigateToTable();
      state.clearShift();
      return;
    }

    if (state.isAlpha && alpha == 'VECTOR') {
      _navigateToVector();
      state.clearAlpha();
      return;
    }
    // Normal button press handling
    state.handleButtonPress(primary: primary, shift: shift, alpha: alpha);
  }

  void _navigateToStats() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const StatisticsPage()),
    );
  }

  void _navigateToEquation() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const EquationPage()),
    );
  }

  void _navigateToVector() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const VectorPage()),
    );
  }

  void _navigateToTable() {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => const TablePage()),
    );
  }

  void _showModeMenu(BuildContext context, CalculatorState state) {
    final theme = context.read<ThemeProvider>().currentTheme;

    showModalBottomSheet(
      context: context,
      backgroundColor: theme.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) => Container(
        padding: const EdgeInsets.all(20),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Mode Settings',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: theme.foreground,
              ),
            ),
            const SizedBox(height: 20),
            ListTile(
              leading: Icon(Icons.calculate, color: theme.primary),
              title: Text(
                'Equation Solver',
                style: TextStyle(color: theme.foreground),
              ),
              subtitle: Text(
                'Solve polynomial & simultaneous equations',
                style: TextStyle(color: theme.muted),
              ),
              onTap: () {
                Navigator.pop(ctx);
                _navigateToEquation();
              },
            ),
            ListTile(
              leading: Icon(Icons.bar_chart, color: theme.primary),
              title: Text(
                'Statistics',
                style: TextStyle(color: theme.foreground),
              ),
              subtitle: Text(
                '1-Variable statistical analysis',
                style: TextStyle(color: theme.muted),
              ),
              onTap: () {
                Navigator.pop(ctx);
                _navigateToStats();
              },
            ),
            ListTile(
              leading: Icon(Icons.table_view, color: theme.primary),
              title: Text('Table', style: TextStyle(color: theme.foreground)),
              subtitle: Text(
                'Single and Dual Function Table Generator',
                style: TextStyle(color: theme.muted),
              ),
              onTap: () {
                Navigator.pop(ctx);
                _navigateToTable();
              },
            ),
            ListTile(
              leading: Icon(Icons.directions, color: theme.primary),
              title: Text('Vector', style: TextStyle(color: theme.foreground)),
              subtitle: Text(
                '2D/3D Vector Calculator',
                style: TextStyle(color: theme.muted),
              ),
              onTap: () {
                Navigator.pop(ctx);
                _navigateToVector();
              },
            ),
            const Divider(),
            ListTile(
              leading: Icon(Icons.settings, color: theme.primary),
              title: Text(
                'Angle Unit',
                style: TextStyle(color: theme.foreground),
              ),
              trailing: SizedBox(
                child: AnimatedBuilder(
                  animation: state,
                  builder: (_, _) {
                    return SegmentedButton<AngleMode>(
                      segments: const [
                        ButtonSegment(
                          value: AngleMode.degrees,
                          label: Text('DEG'),
                        ),
                        ButtonSegment(
                          value: AngleMode.radians,
                          label: Text('RAD'),
                        ),
                      ],
                      selected: {state.angleMode},
                      onSelectionChanged: (s) => state.setAngleMode(s.first),
                      style: SegmentedButton.styleFrom(
                        selectedBackgroundColor: theme.primary,
                        selectedForegroundColor: theme.background,
                      ),
                    );
                  },
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final state = context.watch<CalculatorState>();
    final themeProvider = context.read<ThemeProvider>();
    final theme = themeProvider.currentTheme;

    final shiftColor = theme.shiftColor;
    final alphaColor = theme.alphaColor;
    final isShift = state.isShift;
    final isAlpha = state.isAlpha;

    return Column(
      children: [
        // Display Section
        Container(
          padding: const EdgeInsets.fromLTRB(20, 16, 20, 12),
          decoration: BoxDecoration(
            color: theme.displayBackground,
            border: Border(
              bottom: BorderSide(
                color: theme.subtle.withValues(alpha: 0.3),
                width: 1,
              ),
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withValues(alpha: 0.05),
                blurRadius: 4,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              // Indicators Row
              Row(
                children: [
                  GestureDetector(
                    onTap: state.toggleShift,
                    child: Selector<CalculatorState, bool>(
                      selector: (_, s) => s.isShift,
                      builder: (_, v, _) => _animatedIndicator(
                        'S',
                        shiftColor(theme.background),
                        theme,
                        v,
                      ),
                    ),
                  ),
                  GestureDetector(
                    onTap: state.toggleAlpha,
                    child: Selector<CalculatorState, bool>(
                      selector: (_, s) => s.isAlpha,
                      builder: (_, v, _) => _animatedIndicator(
                        'A',
                        alphaColor(theme.background),
                        theme,
                        v,
                      ),
                    ),
                  ),
                  GestureDetector(
                    onTap: state.toggleHyp,
                    child: Selector<CalculatorState, bool>(
                      selector: (_, s) => s.isHyp,
                      builder: (_, v, _) =>
                          _animatedIndicator('HYP', theme.primary, theme, v),
                    ),
                  ),
                  const SizedBox(width: 8),
                  GestureDetector(
                    onTap: state.toggleAngleMode,
                    child: Selector<CalculatorState, AngleMode>(
                      selector: (_, s) => s.angleMode,
                      builder: (_, mode, _) => _staticIndicator(
                        mode == AngleMode.radians ? 'RAD' : 'DEG',
                        theme.primary,
                        theme,
                      ),
                    ),
                  ),
                  const Spacer(),
                  IconButton(
                    icon: Icon(Icons.apps, color: theme.muted, size: 22),
                    onPressed: () => _showModeMenu(context, state),
                    tooltip: "Mode Menu",
                    visualDensity: VisualDensity.compact,
                  ),
                  IconButton(
                    icon: Icon(
                      Icons.palette_outlined,
                      color: theme.muted,
                      size: 22,
                    ),
                    onPressed: () => _showThemeSettings(context),
                    tooltip: "Themes",
                    visualDensity: VisualDensity.compact,
                  ),
                ],
              ),
              const SizedBox(height: 12),

              // --- Editable Input Display ---
              _buildEditorDisplay(theme, state),

              const SizedBox(height: 8),

              // Result Display
              Selector<CalculatorState, String>(
                selector: (_, s) => s.display,
                builder: (_, value, _) => GestureDetector(
                  onLongPress: () {
                    // Copy the text to the clipboard
                    Clipboard.setData(ClipboardData(text: value));

                    // Optionally, show a confirmation message (e.g., a SnackBar)
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Text copied to clipboard!'),
                        duration: Duration(seconds: 1),
                      ),
                    );
                  },
                  child: Text(
                    value,
                    style: TextStyle(
                      fontSize: 36,
                      fontWeight: FontWeight.w600,
                      color: theme.displayText,
                      letterSpacing: 0.5,
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),

        // Keypad Section
        Expanded(
          child: Container(
            color: theme.background,
            child: GridView.count(
              crossAxisCount: 5,
              padding: const EdgeInsets.all(8),
              mainAxisSpacing: 6,
              crossAxisSpacing: 6,
              childAspectRatio: 1.0,
              children: _buildCalculatorButtons(
                theme,
                shiftColor,
                alphaColor,
                isShift,
                isAlpha,
                state,
              ),
            ),
          ),
        ),
      ],
    );
  }

  // New Editor Display using TextField
  Widget _buildEditorDisplay(AppThemeData theme, CalculatorState state) {
    return SizedBox(
      height: 36, // Fixed height for one line
      child: ShaderMask(
        //TODO: Fix the shader stuff
        shaderCallback: (Rect bounds) {
          return LinearGradient(
            begin: Alignment.centerLeft,
            end: Alignment.centerRight,
            colors: [
              theme.displayBackground,
              theme.displayBackground,
              theme.displayBackground,
              theme.displayBackground,
            ],
            stops: const [0.0, 0.05, 0.95, 1.0], // Tighter stops
          ).createShader(bounds);
        },
        blendMode: BlendMode.dstIn,
        child: TextField(
          controller: state.controller,
          focusNode: _inputFocusNode,
          // Prevent system keyboard but allow cursor movement
          readOnly: true,
          scrollController: state.textScrollController,
          scrollPhysics: const BouncingScrollPhysics(),

          showCursor: true,
          cursorColor: theme.primary,
          cursorWidth: 2,
          cursorRadius: const Radius.circular(2),
          textAlign: TextAlign.right,
          textAlignVertical: TextAlignVertical.center,
          style: TextStyle(
            fontSize: 20,
            fontFamily: 'monospace',
            color: theme.primaryTextColor,
            letterSpacing: 1.0,
          ),
          decoration: const InputDecoration(
            isDense: false,
            filled: false,

            border: InputBorder.none,
            enabledBorder: InputBorder.none,
            focusedBorder: InputBorder.none,
            disabledBorder: InputBorder.none,
            errorBorder: InputBorder.none,
            focusedErrorBorder: InputBorder.none,

            contentPadding: EdgeInsets.fromLTRB(0, 4, 0, 4),
          ),
          maxLines: 1,
        ),
      ),
    );
  }

  Widget _animatedIndicator(
    String label,
    Color color,
    AppThemeData theme,
    bool active,
  ) {
    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      curve: Curves.easeOut,
      margin: const EdgeInsets.only(right: 6),
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
      decoration: BoxDecoration(
        color: active ? color.withValues(alpha: 0.12) : Colors.transparent,
        border: Border.all(
          color: active ? color : color.withValues(alpha: 0.4),
          width: active ? 1.5 : 1,
        ),
        borderRadius: BorderRadius.circular(4),
        boxShadow: active
            ? [
                BoxShadow(
                  color: color.withValues(alpha: 0.3),
                  blurRadius: 4,
                  spreadRadius: 0.5,
                ),
              ]
            : [],
      ),
      child: Text(
        label,
        style: TextStyle(
          fontSize: 10,
          fontWeight: FontWeight.bold,
          color: active ? color : color.withValues(alpha: 0.6),
          letterSpacing: 0.5,
        ),
      ),
    );
  }

  Widget _staticIndicator(String label, Color color, AppThemeData theme) {
    return Container(
      margin: const EdgeInsets.only(right: 6),
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.1),
        border: Border.all(color: color.withValues(alpha: 0.6)),
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        label,
        style: TextStyle(
          fontSize: 10,
          fontWeight: FontWeight.bold,
          color: color,
          letterSpacing: 0.5,
        ),
      ),
    );
  }

  List<Widget> _buildCalculatorButtons(
    AppThemeData theme,
    Function(Color) shiftColor,
    Function(Color) alphaColor,
    bool isShift,
    bool isAlpha,
    CalculatorState state,
  ) {
    Widget btn(
      String label, {
      String? shift,
      String? alpha,
      bool isNumber = false,
      bool isOperator = false,
      bool isFunction = false,
      bool isControl = false,
      VoidCallback? customOnTap,
    }) {
      Color baseColor = isNumber
          ? theme.buttonNumber
          : isOperator
          ? theme.buttonOperator
          : isFunction
          ? theme.buttonFunction
          : isControl
          ? theme.buttonSpecial
          : theme.surface;

      return _CasioButton(
        label: label,
        shiftLabel: shift,
        alphaLabel: alpha,
        isActiveShift: isShift,
        isActiveAlpha: isAlpha,
        textColor: theme.primaryTextColor,
        baseColor: baseColor,
        shiftColor: shiftColor(baseColor),
        alphaColor: alphaColor(baseColor),
        onPressed: customOnTap ?? () => _handlePress(label, shift, alpha),
      );
    }

    return [
      // Row 1: Removed CLR, Split Arrows
      btn('SHIFT', customOnTap: () => state.toggleShift(), isControl: true),
      btn('ALPHA', customOnTap: () => state.toggleAlpha(), isControl: true),
      btn(
        'MODE',
        shift: 'SETUP',
        customOnTap: () => _showModeMenu(context, state),
        isControl: true,
      ),
      btn('←', isControl: true),
      btn('→', isControl: true),

      // Row 2
      btn('x⁻¹', shift: 'x!', alpha: ':', isFunction: true),
      btn('nCr', shift: 'nPr', isFunction: true),
      btn('log', shift: '10ˣ', isFunction: true),
      btn('ln', shift: 'eˣ', isFunction: true),

      // Row 3
      btn('Pol(', shift: 'Rec(', isFunction: true),
      btn('HYP', customOnTap: () => state.toggleHyp(), isFunction: true),
      btn(
        state.isHyp ? 'sinh' : 'sin',
        shift: state.isHyp ? 'sinh⁻¹' : 'sin⁻¹',
        alpha: 'A',
        isFunction: true,
      ),
      btn(
        state.isHyp ? 'cosh' : 'cos',
        shift: state.isHyp ? 'cosh⁻¹' : 'cos⁻¹',
        alpha: 'B',
        isFunction: true,
      ),
      btn(
        state.isHyp ? 'tanh' : 'tan',
        shift: state.isHyp ? 'tanh⁻¹' : 'tan⁻¹',
        alpha: 'C',
        isFunction: true,
      ),
      btn('RCL', shift: 'STO', isFunction: true),

      // Row 4
      btn('x²', shift: '√', alpha: '', isFunction: true),
      btn('x³', shift: '³√', alpha: '', isFunction: true),
      btn('xⁿ', shift: 'ⁿ√', alpha: 'D', isFunction: true),
      btn('(', shift: '', alpha: 'E', isOperator: true),
      btn(')', shift: '', alpha: 'F', isOperator: true),

      // Row 5
      btn('7', shift: 'CONST', alpha: 'off', isNumber: true),
      btn('8', shift: 'CONV', isNumber: true),
      btn('9', shift: 'ARG', isNumber: true),
      btn('DEL', isControl: true),
      btn('AC', shift: 'RESET', isControl: true), // Moved RESET here
      // Row 6
      btn('4', shift: '∫dx', alpha: 'X', isNumber: true),
      btn('5', shift: 'd/dx', alpha: 'Y', isNumber: true),
      btn('6', shift: 'Σ(', alpha: 'Z', isNumber: true),
      btn('×', shift: '%', isOperator: true),
      btn('÷', shift: 'Abs', isOperator: true),

      // Row 7
      btn('1', shift: 'STAT', alpha: 'M', isNumber: true),
      btn('2', shift: 'TABL', alpha: 'i', isNumber: true),
      btn('3', shift: 'EQN', alpha: 'VECTOR', isNumber: true),
      btn('+', shift: 'M+', isOperator: true),
      btn('-', shift: 'M-', isOperator: true),

      // Row 8
      btn('0', shift: 'Rnd', isNumber: true),
      btn(
        '.',
        shift: 'Ran#',
        alpha: 'RanInt',
        isNumber: true,
      ), // Corrected alpha placement
      btn('×10ˣ', shift: 'π', alpha: 'e', isNumber: true),
      btn('Ans', shift: 'DRG', isFunction: true),
      btn(
        '=',
        shift: '≈',
        isControl: true,
        customOnTap: () => state.evaluate(),
      ),
    ];
  }

  void _showThemeSettings(BuildContext context) {
    showDialog(context: context, builder: (_) => const ThemeSettingsDialog());
  }
}

// _CasioButton class remains unchanged (omitted for brevity, assume it's same as provided)
class _CasioButton extends StatelessWidget {
  final String label;
  final String? shiftLabel;
  final String? alphaLabel;
  final bool isActiveShift;
  final bool isActiveAlpha;
  final Color baseColor;
  final Color textColor;
  final Color shiftColor;
  final Color alphaColor;
  final VoidCallback onPressed;

  const _CasioButton({
    required this.label,
    this.shiftLabel,
    this.alphaLabel,
    required this.isActiveShift,
    required this.isActiveAlpha,
    required this.baseColor,
    required this.textColor,
    required this.shiftColor,
    required this.alphaColor,
    required this.onPressed,
  });

  double _buttonFontSize(String label, bool isCenter) {
    if (isCenter) {
      // Heavy math / operators
      if (RegExp(r'[∫Σ√π]').hasMatch(label)) return 16;

      // Superscripts / scientific notation
      if (label.contains('ˣ') || label.contains('⁻¹')) return 15;

      // Long textual labels
      if (label.length >= 4) return 14;

      // Normal digits / ops
      return 18;
    } else {
      // Heavy math / operators
      if (RegExp(r'[∫Σ√π]').hasMatch(label)) return 18;

      // Superscripts / scientific notation
      if (label.contains('ˣ') || label.contains('⁻¹')) return 14;

      if (label.length <= 2) return 14;

      return 10;
    }
  }

  @override
  Widget build(BuildContext context) {
    Color mainLabelColor = textColor;
    if (isActiveShift && shiftLabel != null) {
      mainLabelColor = textColor.withOpacity(0.3);
    }
    if (isActiveAlpha && alphaLabel != null) {
      mainLabelColor = textColor.withOpacity(0.3);
    }

    return Material(
      color: baseColor,
      borderRadius: BorderRadius.circular(8),
      elevation: 1,
      shadowColor: Colors.black.withOpacity(0.1),
      child: InkWell(
        onTap: onPressed,
        borderRadius: BorderRadius.circular(8),
        splashColor: Colors.white.withOpacity(0.2),
        highlightColor: Colors.white.withOpacity(0.1),
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: Colors.black.withOpacity(0.1),
              width: 0.5,
            ),
          ),
          child: Stack(
            children: [
              Center(
                child: Text(
                  label,
                  style: TextStyle(
                    fontSize: _buttonFontSize(label, true),
                    fontWeight: FontWeight.w600,
                    color: mainLabelColor,
                    height: 1.0, // prevents vertical shrink
                    fontFamilyFallback: const [
                      'Roboto',
                      'Noto Sans Math',
                      'Noto Sans Symbols',
                      'Segoe UI Symbol',
                    ],
                  ),
                ),
              ),
              if (shiftLabel != null)
                Positioned(
                  left: 4,
                  top: 3,
                  child: Text(
                    shiftLabel!,

                    style: TextStyle(
                      fontSize: _buttonFontSize(shiftLabel!, false),
                      fontWeight: FontWeight.bold,
                      height: 1.0, // prevents vertical shrink
                      fontFamilyFallback: const [
                        'Roboto',
                        'Noto Sans Math',
                        'Noto Sans Symbols',
                        'Segoe UI Symbol',
                      ],
                      color: isActiveShift
                          ? shiftColor
                          : shiftColor.withOpacity(0.6),
                      decoration: isActiveShift
                          ? TextDecoration.underline
                          : null,
                    ),
                  ),
                ),
              if (alphaLabel != null)
                Positioned(
                  right: 4,
                  top: 3,
                  child: Text(
                    alphaLabel!,
                    style: TextStyle(
                      fontSize: _buttonFontSize(alphaLabel!, false),
                      height: 1.0, // prevents vertical shrink
                      fontFamilyFallback: const [
                        'Roboto',
                        'Noto Sans Math',
                        'Noto Sans Symbols',
                        'Segoe UI Symbol',
                      ],
                      fontWeight: FontWeight.bold,
                      color: isActiveAlpha
                          ? alphaColor
                          : alphaColor.withOpacity(0.6),
                      decoration: isActiveAlpha
                          ? TextDecoration.underline
                          : null,
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}
import 'dart:math';
import 'package:app/theme/theme_provider.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

enum StatMode { oneVar, twoVar }

enum RegressionType { linear, quadratic, exponential, power, logarithmic }

class StatisticsPage extends StatefulWidget {
  const StatisticsPage({Key? key}) : super(key: key);

  @override
  State<StatisticsPage> createState() => _StatisticsPageState();
}

class _StatisticsPageState extends State<StatisticsPage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  // Data storage
  final List<double> _xData = [];
  final List<double> _yData = [];
  final List<int> _freq = [];

  // Controllers
  final TextEditingController _xController = TextEditingController();
  final TextEditingController _yController = TextEditingController();
  final TextEditingController _freqController = TextEditingController();

  StatMode _mode = StatMode.oneVar;
  RegressionType _regType = RegressionType.linear;
  bool _useFrequency = false;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    _xController.dispose();
    _yController.dispose();
    _freqController.dispose();
    super.dispose();
  }

  void _addData() {
    final x = double.tryParse(_xController.text);
    if (x == null) return;

    final y = _mode == StatMode.twoVar
        ? double.tryParse(_yController.text)
        : null;

    final freq = _useFrequency ? int.tryParse(_freqController.text) ?? 1 : 1;

    if (_mode == StatMode.twoVar && y == null) return;

    setState(() {
      _xData.add(x);
      if (_mode == StatMode.twoVar) _yData.add(y!);
      _freq.add(freq);
    });

    _xController.clear();
    _yController.clear();
    _freqController.clear();
  }

  void _clearData() {
    setState(() {
      _xData.clear();
      _yData.clear();
      _freq.clear();
    });
  }

  void _removeAt(int index) {
    setState(() {
      _xData.removeAt(index);
      if (_mode == StatMode.twoVar) _yData.removeAt(index);
      _freq.removeAt(index);
    });
  }

  Map<String, double> _calculate1Var() {
    if (_xData.isEmpty) return {};

    double n = _useFrequency
        ? _freq.reduce((a, b) => a + b).toDouble()
        : _xData.length.toDouble();

    double sumX = 0, sumX2 = 0;
    for (int i = 0; i < _xData.length; i++) {
      final f = _useFrequency ? _freq[i] : 1;
      sumX += _xData[i] * f;
      sumX2 += _xData[i] * _xData[i] * f;
    }

    double mean = sumX / n;
    double variance = (sumX2 / n) - (mean * mean);
    double sampleVar = n > 1 ? (sumX2 - (sumX * sumX) / n) / (n - 1) : 0;

    final expandedData = <double>[];
    for (int i = 0; i < _xData.length; i++) {
      final f = _useFrequency ? _freq[i] : 1;
      for (int j = 0; j < f; j++) {
        expandedData.add(_xData[i]);
      }
    }
    expandedData.sort();

    double median;
    final len = expandedData.length;
    if (len % 2 == 0) {
      median = (expandedData[len ~/ 2 - 1] + expandedData[len ~/ 2]) / 2;
    } else {
      median = expandedData[len ~/ 2];
    }

    return {
      'n': n,
      'Σx': sumX,
      'Σx²': sumX2,
      'x̄': mean,
      'σx': sqrt(variance),
      'sx': sqrt(sampleVar),
      'Med': median,
      'minX': _xData.reduce(min),
      'maxX': _xData.reduce(max),
    };
  }

  Map<String, double> _calculate2Var() {
    if (_xData.isEmpty || _yData.isEmpty) return {};

    double n = _useFrequency
        ? _freq.reduce((a, b) => a + b).toDouble()
        : _xData.length.toDouble();

    double sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0, sumXY = 0;

    for (int i = 0; i < _xData.length; i++) {
      final f = _useFrequency ? _freq[i] : 1;
      sumX += _xData[i] * f;
      sumY += _yData[i] * f;
      sumX2 += _xData[i] * _xData[i] * f;
      sumY2 += _yData[i] * _yData[i] * f;
      sumXY += _xData[i] * _yData[i] * f;
    }

    double meanX = sumX / n;
    double meanY = sumY / n;

    // Regression coefficients (linear: y = a + bx)
    double b = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    double a = meanY - b * meanX;

    // Correlation coefficient
    double r =
        (n * sumXY - sumX * sumY) /
        sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

    return {
      'n': n,
      'Σx': sumX,
      'Σy': sumY,
      'Σx²': sumX2,
      'Σy²': sumY2,
      'Σxy': sumXY,
      'x̄': meanX,
      'ȳ': meanY,
      'σx': sqrt((sumX2 / n) - (meanX * meanX)),
      'σy': sqrt((sumY2 / n) - (meanY * meanY)),
      'a': a,
      'b': b,
      'r': r,
      'r²': r * r,
    };
  }

  @override
  Widget build(BuildContext context) {
    final theme = context.watch<ThemeProvider>().currentTheme;

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        title: const Text('Statistics'),
        backgroundColor: theme.surface,
        foregroundColor: theme.foreground,
        elevation: 0,
        bottom: TabBar(
          controller: _tabController,
          indicatorColor: theme.primary,
          labelColor: theme.primary,
          unselectedLabelColor: theme.muted,
          tabs: const [
            Tab(text: 'Data Entry'),
            Tab(text: 'Results'),
          ],
        ),
        actions: [
          PopupMenuButton(
            icon: Icon(Icons.settings, color: theme.muted),
            color: theme.surface,
            itemBuilder: (context) => [
              PopupMenuItem(
                child: StatefulBuilder(
                  builder: (context, setState) => SwitchListTile(
                    title: Text(
                      'Frequency',
                      style: TextStyle(color: theme.foreground),
                    ),
                    value: _useFrequency,
                    activeColor: theme.primary,
                    onChanged: (val) {
                      setState(() => _useFrequency = val);
                      this.setState(() => _useFrequency = val);
                    },
                  ),
                ),
              ),
            ],
          ),
          if (_xData.isNotEmpty)
            IconButton(
              icon: Icon(Icons.delete_sweep, color: theme.error),
              onPressed: _clearData,
            ),
        ],
      ),
      body: TabBarView(
        controller: _tabController,
        children: [_buildDataEntry(theme), _buildResults(theme)],
      ),
    );
  }

  Widget _buildDataEntry(dynamic theme) {
    return Column(
      children: [
        // Mode selector
        Container(
          padding: const EdgeInsets.all(16),
          color: theme.surface,
          child: Row(
            children: [
              Text(
                'Mode:',
                style: TextStyle(
                  color: theme.foreground,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: SegmentedButton<StatMode>(
                  segments: const [
                    ButtonSegment(value: StatMode.oneVar, label: Text('1-VAR')),
                    ButtonSegment(value: StatMode.twoVar, label: Text('2-VAR')),
                  ],
                  selected: {_mode},
                  onSelectionChanged: (Set<StatMode> sel) {
                    setState(() {
                      _mode = sel.first;
                      _clearData();
                    });
                  },
                  style: SegmentedButton.styleFrom(
                    selectedBackgroundColor: theme.primary,
                    selectedForegroundColor: theme.background,
                  ),
                ),
              ),
            ],
          ),
        ),

        // Input fields
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: theme.surface,
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.05),
                blurRadius: 4,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            children: [
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      controller: _xController,
                      keyboardType: const TextInputType.numberWithOptions(
                        decimal: true,
                        signed: true,
                      ),
                      style: TextStyle(color: theme.foreground),
                      decoration: InputDecoration(
                        labelText: _mode == StatMode.oneVar ? 'Value (x)' : 'X',
                        labelStyle: TextStyle(color: theme.primary),
                        filled: true,
                        fillColor: theme.background,
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      onSubmitted: (_) => _addData(),
                    ),
                  ),
                  if (_mode == StatMode.twoVar) ...[
                    const SizedBox(width: 12),
                    Expanded(
                      child: TextField(
                        controller: _yController,
                        keyboardType: const TextInputType.numberWithOptions(
                          decimal: true,
                          signed: true,
                        ),
                        style: TextStyle(color: theme.foreground),
                        decoration: InputDecoration(
                          labelText: 'Y',
                          labelStyle: TextStyle(color: theme.primary),
                          filled: true,
                          fillColor: theme.background,
                          border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                        onSubmitted: (_) => _addData(),
                      ),
                    ),
                  ],
                  if (_useFrequency) ...[
                    const SizedBox(width: 12),
                    SizedBox(
                      width: 80,
                      child: TextField(
                        controller: _freqController,
                        keyboardType: TextInputType.number,
                        style: TextStyle(color: theme.foreground),
                        decoration: InputDecoration(
                          labelText: 'FREQ',
                          labelStyle: TextStyle(color: theme.primary),
                          filled: true,
                          fillColor: theme.background,
                          border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                        onSubmitted: (_) => _addData(),
                      ),
                    ),
                  ],
                  const SizedBox(width: 12),
                  ElevatedButton(
                    onPressed: _addData,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: theme.primary,
                      padding: const EdgeInsets.all(16),
                    ),
                    child: const Icon(Icons.add),
                  ),
                ],
              ),
            ],
          ),
        ),

        // Data table
        Expanded(
          child: _xData.isEmpty
              ? Center(
                  child: Text(
                    'No data entered',
                    style: TextStyle(color: theme.muted, fontSize: 16),
                  ),
                )
              : ListView.builder(
                  padding: const EdgeInsets.all(8),
                  itemCount: _xData.length,
                  itemBuilder: (context, i) {
                    return Card(
                      color: theme.surface,
                      margin: const EdgeInsets.only(bottom: 8),
                      child: ListTile(
                        leading: CircleAvatar(
                          backgroundColor: theme.primary.withOpacity(0.2),
                          child: Text(
                            '${i + 1}',
                            style: TextStyle(color: theme.primary),
                          ),
                        ),
                        title: Row(
                          children: [
                            Expanded(
                              child: Text(
                                'X: ${_xData[i]}',
                                style: TextStyle(
                                  color: theme.foreground,
                                  fontFamily: 'monospace',
                                ),
                              ),
                            ),
                            if (_mode == StatMode.twoVar)
                              Expanded(
                                child: Text(
                                  'Y: ${_yData[i]}',
                                  style: TextStyle(
                                    color: theme.foreground,
                                    fontFamily: 'monospace',
                                  ),
                                ),
                              ),
                            if (_useFrequency)
                              Text(
                                'F: ${_freq[i]}',
                                style: TextStyle(
                                  color: theme.muted,
                                  fontSize: 12,
                                ),
                              ),
                          ],
                        ),
                        trailing: IconButton(
                          icon: Icon(Icons.close, color: theme.error),
                          onPressed: () => _removeAt(i),
                        ),
                      ),
                    );
                  },
                ),
        ),
      ],
    );
  }

  Widget _buildResults(dynamic theme) {
    final stats = _mode == StatMode.oneVar
        ? _calculate1Var()
        : _calculate2Var();

    if (stats.isEmpty) {
      return Center(
        child: Text(
          'Enter data to see results',
          style: TextStyle(color: theme.muted),
        ),
      );
    }

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        if (_mode == StatMode.twoVar) ...[
          _buildSection(theme, 'Regression Type', [
            SegmentedButton<RegressionType>(
              segments: const [
                ButtonSegment(
                  value: RegressionType.linear,
                  label: Text('y=a+bx'),
                ),
                ButtonSegment(
                  value: RegressionType.quadratic,
                  label: Text('y=a+bx+cx²'),
                ),
              ],
              selected: {_regType},
              onSelectionChanged: (sel) => setState(() => _regType = sel.first),
              style: SegmentedButton.styleFrom(
                selectedBackgroundColor: theme.primary,
                selectedForegroundColor: theme.background,
              ),
            ),
          ]),
          const SizedBox(height: 16),
        ],

        _buildSection(
          theme,
          _mode == StatMode.oneVar ? '1-Variable Stats' : 'X Statistics',
          stats.entries
              .map((e) => _buildStatRow(theme, e.key, e.value))
              .toList(),
        ),
      ],
    );
  }

  Widget _buildSection(dynamic theme, String title, List<Widget> children) {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.subtle),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
              color: theme.primary,
            ),
          ),
          const SizedBox(height: 12),
          ...children,
        ],
      ),
    );
  }

  Widget _buildStatRow(dynamic theme, String label, double value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: TextStyle(
              color: theme.foreground,
              fontWeight: FontWeight.w600,
            ),
          ),
          Text(
            _formatValue(value),
            style: TextStyle(
              color: theme.primary,
              fontFamily: 'monospace',
              fontSize: 16,
            ),
          ),
        ],
      ),
    );
  }

  String _formatValue(double val) {
    if (val.abs() >= 1e6 || (val.abs() < 1e-4 && val != 0)) {
      return val.toStringAsExponential(6);
    }
    return val.toStringAsFixed(8).replaceFirst(RegExp(r'\.?0+$'), '');
  }
}
import 'package:app/core/evaluator/eval_context.dart';
import 'package:app/core/evaluator/eval_types.dart';
import 'package:app/services/calculator_service.dart';
import 'package:app/theme/theme_provider.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

class TablePage extends StatefulWidget {
  const TablePage({Key? key}) : super(key: key);

  @override
  State<TablePage> createState() => _TablePageState();
}

class _TablePageState extends State<TablePage> {
  final TextEditingController _fxController = TextEditingController();
  final TextEditingController _gxController = TextEditingController();
  final TextEditingController _startController = TextEditingController(
    text: '0',
  );
  final TextEditingController _endController = TextEditingController(
    text: '10',
  );
  final TextEditingController _stepController = TextEditingController(
    text: '1',
  );

  bool _useTwoFunctions = false;
  List<Map<String, double>> _tableData = [];
  String? _error;

  @override
  void dispose() {
    _fxController.dispose();
    _gxController.dispose();
    _startController.dispose();
    _endController.dispose();
    _stepController.dispose();
    super.dispose();
  }

  void _generateTable() {
    setState(() {
      _error = null;
      _tableData.clear();
    });

    final fx = _fxController.text.trim();
    if (fx.isEmpty) {
      setState(() => _error = 'Enter f(x)');
      return;
    }

    final start = double.tryParse(_startController.text);
    final end = double.tryParse(_endController.text);
    final step = double.tryParse(_stepController.text);

    if (start == null || end == null || step == null || step == 0) {
      setState(() => _error = 'Invalid range or step');
      return;
    }

    if ((end - start) / step > 1000) {
      setState(() => _error = 'Too many points (max 1000)');
      return;
    }

    final calculator = context.read<CalculatorService>();

    try {
      for (double x = start; x <= end; x += step) {
        final row = <String, double>{'x': x};

        // Evaluate f(x)
        final fResult = calculator.evaluate(
          fx,
          AngleMode.rad,
          EvalContext(variables: {'x': x}),
        );

        if (fResult is EvalSuccess) {
          row['f(x)'] = fResult.value;
        } else {
          row['f(x)'] = double.nan;
        }

        // Evaluate g(x) if enabled
        if (_useTwoFunctions && _gxController.text.isNotEmpty) {
          final gx = _gxController.text.trim();
          final gResult = calculator.evaluate(
            gx,
            AngleMode.rad,
            EvalContext(variables: {'x': x}),
          );

          if (gResult is EvalSuccess) {
            row['g(x)'] = gResult.value;
          } else {
            row['g(x)'] = double.nan;
          }
        }

        setState(() => _tableData.add(row));
      }
    } catch (e) {
      setState(() => _error = 'Evaluation error: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = context.watch<ThemeProvider>().currentTheme;

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        title: const Text('Table Generator'),
        backgroundColor: theme.surface,
        foregroundColor: theme.foreground,
        elevation: 0,
        actions: [
          PopupMenuButton(
            icon: Icon(Icons.settings, color: theme.muted),
            color: theme.surface,
            itemBuilder: (context) => [
              PopupMenuItem(
                child: StatefulBuilder(
                  builder: (context, setState) => SwitchListTile(
                    title: Text(
                      'Two Functions',
                      style: TextStyle(color: theme.foreground),
                    ),
                    subtitle: Text(
                      'f(x) and g(x)',
                      style: TextStyle(color: theme.muted, fontSize: 12),
                    ),
                    value: _useTwoFunctions,
                    activeColor: theme.primary,
                    onChanged: (val) {
                      setState(() => _useTwoFunctions = val);
                      this.setState(() => _useTwoFunctions = val);
                    },
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
      body: Column(
        children: [
          // Function input
          Container(
            padding: const EdgeInsets.all(16),
            color: theme.surface,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Function Definition',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: theme.foreground,
                  ),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: _fxController,
                  style: TextStyle(
                    color: theme.foreground,
                    fontFamily: 'monospace',
                  ),
                  decoration: InputDecoration(
                    labelText: 'f(x)',
                    hintText: 'e.g., x^2 + 2*x + 1',
                    labelStyle: TextStyle(color: theme.primary),
                    hintStyle: TextStyle(color: theme.muted.withOpacity(0.5)),
                    filled: true,
                    fillColor: theme.background,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                  ),
                ),
                if (_useTwoFunctions) ...[
                  const SizedBox(height: 12),
                  TextField(
                    controller: _gxController,
                    style: TextStyle(
                      color: theme.foreground,
                      fontFamily: 'monospace',
                    ),
                    decoration: InputDecoration(
                      labelText: 'g(x)',
                      hintText: 'e.g., sin(x)',
                      labelStyle: TextStyle(color: theme.primary),
                      hintStyle: TextStyle(color: theme.muted.withOpacity(0.5)),
                      filled: true,
                      fillColor: theme.background,
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                    ),
                  ),
                ],
              ],
            ),
          ),

          // Range settings
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: theme.surface,
              border: Border(top: BorderSide(color: theme.subtle)),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Table Range',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: theme.foreground,
                  ),
                ),
                const SizedBox(height: 12),
                Row(
                  children: [
                    Expanded(
                      child: TextField(
                        controller: _startController,
                        keyboardType: const TextInputType.numberWithOptions(
                          decimal: true,
                          signed: true,
                        ),
                        style: TextStyle(color: theme.foreground),
                        decoration: InputDecoration(
                          labelText: 'Start',
                          labelStyle: TextStyle(color: theme.primary),
                          filled: true,
                          fillColor: theme.background,
                          border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: TextField(
                        controller: _endController,
                        keyboardType: const TextInputType.numberWithOptions(
                          decimal: true,
                          signed: true,
                        ),
                        style: TextStyle(color: theme.foreground),
                        decoration: InputDecoration(
                          labelText: 'End',
                          labelStyle: TextStyle(color: theme.primary),
                          filled: true,
                          fillColor: theme.background,
                          border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: TextField(
                        controller: _stepController,
                        keyboardType: const TextInputType.numberWithOptions(
                          decimal: true,
                          signed: true,
                        ),
                        style: TextStyle(color: theme.foreground),
                        decoration: InputDecoration(
                          labelText: 'Step',
                          labelStyle: TextStyle(color: theme.primary),
                          filled: true,
                          fillColor: theme.background,
                          border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton.icon(
                    onPressed: _generateTable,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: theme.primary,
                      foregroundColor: theme.background,
                      padding: const EdgeInsets.all(16),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                    ),
                    icon: const Icon(Icons.table_chart),
                    label: const Text('GENERATE TABLE'),
                  ),
                ),
              ],
            ),
          ),

          // Error message
          if (_error != null)
            Container(
              padding: const EdgeInsets.all(12),
              color: theme.error.withOpacity(0.1),
              child: Row(
                children: [
                  Icon(Icons.error_outline, color: theme.error),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(_error!, style: TextStyle(color: theme.error)),
                  ),
                ],
              ),
            ),

          // Table display
          Expanded(
            child: _tableData.isEmpty
                ? Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.table_chart_outlined,
                          size: 80,
                          color: theme.muted.withOpacity(0.3),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'No table generated',
                          style: TextStyle(color: theme.muted, fontSize: 16),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'Enter function and generate',
                          style: TextStyle(
                            color: theme.muted.withOpacity(0.7),
                            fontSize: 14,
                          ),
                        ),
                      ],
                    ),
                  )
                : SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    child: SingleChildScrollView(
                      child: DataTable(
                        headingRowColor: MaterialStateProperty.all(
                          theme.surface,
                        ),
                        dataRowColor: MaterialStateProperty.all(
                          theme.background,
                        ),
                        border: TableBorder.all(color: theme.subtle, width: 1),
                        columns: [
                          DataColumn(
                            label: Text(
                              'x',
                              style: TextStyle(
                                color: theme.primary,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                          DataColumn(
                            label: Text(
                              'f(x)',
                              style: TextStyle(
                                color: theme.primary,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                          if (_useTwoFunctions)
                            DataColumn(
                              label: Text(
                                'g(x)',
                                style: TextStyle(
                                  color: theme.primary,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                        ],
                        rows: _tableData.map((row) {
                          return DataRow(
                            cells: [
                              DataCell(
                                Text(
                                  _format(row['x']!),
                                  style: TextStyle(
                                    color: theme.foreground,
                                    fontFamily: 'monospace',
                                  ),
                                ),
                              ),
                              DataCell(
                                Text(
                                  _format(row['f(x)']!),
                                  style: TextStyle(
                                    color: theme.foreground,
                                    fontFamily: 'monospace',
                                  ),
                                ),
                              ),
                              if (_useTwoFunctions)
                                DataCell(
                                  Text(
                                    _format(row['g(x)']!),
                                    style: TextStyle(
                                      color: theme.foreground,
                                      fontFamily: 'monospace',
                                    ),
                                  ),
                                ),
                            ],
                          );
                        }).toList(),
                      ),
                    ),
                  ),
          ),
        ],
      ),
    );
  }

  String _format(double val) {
    if (val.isNaN) return 'ERROR';
    if (val.isInfinite) return val > 0 ? '∞' : '-∞';
    if (val.abs() >= 1e6 || (val.abs() < 1e-4 && val != 0)) {
      return val.toStringAsExponential(4);
    }
    return val.toStringAsFixed(6).replaceFirst(RegExp(r'\.?0+$'), '');
  }
}
import 'dart:math' as math;
import 'package:app/theme/theme_provider.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

class Vector {
  final List<double> components;

  Vector(this.components);

  int get dimension => components.length;

  double get magnitude =>
      math.sqrt(components.fold(0.0, (sum, c) => sum + c * c));

  Vector operator +(Vector other) {
    if (dimension != other.dimension) throw ArgumentError('Dimension mismatch');
    return Vector(
      List.generate(dimension, (i) => components[i] + other.components[i]),
    );
  }

  Vector operator -(Vector other) {
    if (dimension != other.dimension) throw ArgumentError('Dimension mismatch');
    return Vector(
      List.generate(dimension, (i) => components[i] - other.components[i]),
    );
  }

  Vector operator *(double scalar) {
    return Vector(components.map((c) => c * scalar).toList());
  }

  double dot(Vector other) {
    if (dimension != other.dimension) throw ArgumentError('Dimension mismatch');
    return List.generate(
      dimension,
      (i) => components[i] * other.components[i],
    ).fold(0.0, (sum, v) => sum + v);
  }

  Vector? cross(Vector other) {
    if (dimension != 3 || other.dimension != 3) return null;
    return Vector([
      components[1] * other.components[2] - components[2] * other.components[1],
      components[2] * other.components[0] - components[0] * other.components[2],
      components[0] * other.components[1] - components[1] * other.components[0],
    ]);
  }

  double angle(Vector other) {
    final dotProduct = dot(other);
    final magnitudes = magnitude * other.magnitude;
    if (magnitudes == 0) return 0;
    return math.acos((dotProduct / magnitudes).clamp(-1.0, 1.0));
  }

  @override
  String toString() =>
      '(${components.map((c) => c.toStringAsFixed(4)).join(', ')})';
}

class VectorPage extends StatefulWidget {
  const VectorPage({Key? key}) : super(key: key);

  @override
  State<VectorPage> createState() => _VectorPageState();
}

class _VectorPageState extends State<VectorPage> {
  final Map<String, Vector?> _vectors = {
    'VctA': null,
    'VctB': null,
    'VctC': null,
    'VctD': null,
  };

  String _result = '';
  String? _error;

  void _defineVector(String name) {
    showDialog(
      context: context,
      builder: (ctx) => _VectorInputDialog(
        name: name,
        onSave: (vector) {
          setState(() {
            _vectors[name] = vector;
            _error = null;
          });
        },
      ),
    );
  }

  void _performOperation(String operation) {
    setState(() {
      _error = null;
      _result = '';
    });

    try {
      switch (operation) {
        case 'A+B':
          _binaryOp((a, b) => (a + b).toString(), 'VctA', 'VctB');
          break;
        case 'A-B':
          _binaryOp((a, b) => (a - b).toString(), 'VctA', 'VctB');
          break;
        case 'A·B':
          _binaryOp((a, b) => a.dot(b).toStringAsFixed(6), 'VctA', 'VctB');
          break;
        case 'A×B':
          _crossProduct('VctA', 'VctB');
          break;
        case 'Angle(A,B)':
          _angleCalc('VctA', 'VctB');
          break;
        case '|A|':
          _magnitude('VctA');
          break;
        case '2A':
          _scalarMultiply('VctA', 2);
          break;
      }
    } catch (e) {
      setState(() => _error = e.toString());
    }
  }

  void _binaryOp(String Function(Vector, Vector) op, String v1, String v2) {
    final a = _vectors[v1];
    final b = _vectors[v2];

    if (a == null || b == null) {
      setState(() => _error = 'Vectors not defined');
      return;
    }

    setState(() => _result = op(a, b));
  }

  void _crossProduct(String v1, String v2) {
    final a = _vectors[v1];
    final b = _vectors[v2];

    if (a == null || b == null) {
      setState(() => _error = 'Vectors not defined');
      return;
    }

    if (a.dimension != 3 || b.dimension != 3) {
      setState(() => _error = 'Cross product requires 3D vectors');
      return;
    }

    final result = a.cross(b);
    if (result != null) {
      setState(() => _result = result.toString());
    }
  }

  void _angleCalc(String v1, String v2) {
    final a = _vectors[v1];
    final b = _vectors[v2];

    if (a == null || b == null) {
      setState(() => _error = 'Vectors not defined');
      return;
    }

    final angleRad = a.angle(b);
    final angleDeg = angleRad * 180 / math.pi;
    setState(
      () => _result =
          '${angleRad.toStringAsFixed(6)} rad (${angleDeg.toStringAsFixed(2)}°)',
    );
  }

  void _magnitude(String v) {
    final vec = _vectors[v];
    if (vec == null) {
      setState(() => _error = 'Vector not defined');
      return;
    }
    setState(() => _result = vec.magnitude.toStringAsFixed(6));
  }

  void _scalarMultiply(String v, double scalar) {
    final vec = _vectors[v];
    if (vec == null) {
      setState(() => _error = 'Vector not defined');
      return;
    }
    setState(() => _result = (vec * scalar).toString());
  }

  @override
  Widget build(BuildContext context) {
    final theme = context.watch<ThemeProvider>().currentTheme;

    return Scaffold(
      backgroundColor: theme.background,
      appBar: AppBar(
        title: const Text('Vector Calculator'),
        backgroundColor: theme.surface,
        foregroundColor: theme.foreground,
        elevation: 0,
      ),
      body: Column(
        children: [
          // Defined vectors display
          Container(
            padding: const EdgeInsets.all(16),
            color: theme.surface,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(
                  'Defined Vectors',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    color: theme.foreground,
                  ),
                ),
                const SizedBox(height: 12),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: _vectors.entries.map((entry) {
                    final defined = entry.value != null;
                    return ActionChip(
                      label: Text(
                        entry.key,
                        style: TextStyle(
                          color: defined ? theme.background : theme.foreground,
                        ),
                      ),
                      backgroundColor: defined ? theme.primary : theme.surface,
                      side: BorderSide(
                        color: defined ? theme.primary : theme.subtle,
                      ),
                      onPressed: () => _defineVector(entry.key),
                    );
                  }).toList(),
                ),
              ],
            ),
          ),

          // Vector values
          if (_vectors.values.any((v) => v != null))
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: theme.background,
                border: Border(top: BorderSide(color: theme.subtle)),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: _vectors.entries
                    .where((e) => e.value != null)
                    .map(
                      (e) => Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: Row(
                          children: [
                            SizedBox(
                              width: 60,
                              child: Text(
                                '${e.key}:',
                                style: TextStyle(
                                  color: theme.primary,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                            Text(
                              e.value.toString(),
                              style: TextStyle(
                                color: theme.foreground,
                                fontFamily: 'monospace',
                              ),
                            ),
                          ],
                        ),
                      ),
                    )
                    .toList(),
              ),
            ),

          // Operations
          Expanded(
            child: ListView(
              padding: const EdgeInsets.all(16),
              children: [
                _buildOperationSection(theme, 'Basic Operations', [
                  _buildOpButton(theme, 'A + B', 'A+B'),
                  _buildOpButton(theme, 'A - B', 'A-B'),
                  _buildOpButton(theme, '2 × A', '2A'),
                  _buildOpButton(theme, '|A| (Magnitude)', '|A|'),
                ]),
                const SizedBox(height: 16),
                _buildOperationSection(theme, 'Advanced Operations', [
                  _buildOpButton(theme, 'A · B (Dot Product)', 'A·B'),
                  _buildOpButton(theme, 'A × B (Cross Product)', 'A×B'),
                  _buildOpButton(theme, 'Angle(A, B)', 'Angle(A,B)'),
                ]),
              ],
            ),
          ),

          // Result display
          if (_result.isNotEmpty || _error != null)
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: _error != null
                    ? theme.error.withOpacity(0.1)
                    : theme.primary.withOpacity(0.1),
                border: Border(
                  top: BorderSide(
                    color: _error != null ? theme.error : theme.primary,
                    width: 2,
                  ),
                ),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Icon(
                        _error != null
                            ? Icons.error_outline
                            : Icons.check_circle,
                        color: _error != null ? theme.error : theme.primary,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        _error != null ? 'Error' : 'Result',
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: _error != null ? theme.error : theme.primary,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    _error ?? _result,
                    style: TextStyle(
                      color: theme.foreground,
                      fontSize: 18,
                      fontFamily: 'monospace',
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildOperationSection(
    dynamic theme,
    String title,
    List<Widget> buttons,
  ) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.subtle),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: theme.foreground,
            ),
          ),
          const SizedBox(height: 12),
          Wrap(spacing: 8, runSpacing: 8, children: buttons),
        ],
      ),
    );
  }

  Widget _buildOpButton(dynamic theme, String label, String operation) {
    return ElevatedButton(
      onPressed: () => _performOperation(operation),
      style: ElevatedButton.styleFrom(
        backgroundColor: theme.primary,
        foregroundColor: theme.background,
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      ),
      child: Text(label),
    );
  }
}

class _VectorInputDialog extends StatefulWidget {
  final String name;
  final Function(Vector) onSave;

  const _VectorInputDialog({required this.name, required this.onSave});

  @override
  State<_VectorInputDialog> createState() => _VectorInputDialogState();
}

class _VectorInputDialogState extends State<_VectorInputDialog> {
  int _dimension = 3;
  final List<TextEditingController> _controllers = List.generate(
    3,
    (_) => TextEditingController(),
  );

  @override
  void dispose() {
    for (var ctrl in _controllers) {
      ctrl.dispose();
    }
    super.dispose();
  }

  void _save() {
    final components = <double>[];
    for (int i = 0; i < _dimension; i++) {
      final val = double.tryParse(_controllers[i].text);
      if (val == null) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('Invalid number entered')));
        return;
      }
      components.add(val);
    }

    widget.onSave(Vector(components));
    Navigator.pop(context);
  }

  @override
  Widget build(BuildContext context) {
    final theme = context.watch<ThemeProvider>().currentTheme;

    return AlertDialog(
      backgroundColor: theme.surface,
      title: Text(
        'Define ${widget.name}',
        style: TextStyle(color: theme.foreground),
      ),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          SegmentedButton<int>(
            segments: const [
              ButtonSegment(value: 2, label: Text('2D')),
              ButtonSegment(value: 3, label: Text('3D')),
            ],
            selected: {_dimension},
            onSelectionChanged: (Set<int> sel) {
              setState(() => _dimension = sel.first);
            },
            style: SegmentedButton.styleFrom(
              selectedBackgroundColor: theme.primary,
              selectedForegroundColor: theme.background,
            ),
          ),
          const SizedBox(height: 16),
          ..._buildInputs(theme),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text('Cancel', style: TextStyle(color: theme.muted)),
        ),
        ElevatedButton(
          onPressed: _save,
          style: ElevatedButton.styleFrom(backgroundColor: theme.primary),
          child: Text('Save', style: TextStyle(color: theme.primaryTextColor)),
        ),
      ],
    );
  }

  List<Widget> _buildInputs(dynamic theme) {
    final labels = ['x', 'y', 'z'];
    return List.generate(_dimension, (i) {
      return Padding(
        padding: const EdgeInsets.only(bottom: 12),
        child: TextField(
          controller: _controllers[i],
          keyboardType: const TextInputType.numberWithOptions(
            decimal: true,
            signed: true,
          ),
          style: TextStyle(color: theme.foreground),
          decoration: InputDecoration(
            labelText: labels[i],
            labelStyle: TextStyle(color: theme.primary),
            filled: true,
            fillColor: theme.background,
            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
          ),
        ),
      );
    });
  }
}
// ============================================================================
// FILE: core/engine/binder/binder.dart
// Binds AST to typed, resolved Bound AST
// ============================================================================

import 'package:app/core/engine/binder/bound_ast.dart';
import 'package:app/core/engine/binder/symbol_table.dart';
import 'package:app/core/engine/library/standard_library.dart';
import 'package:app/core/engine/parser/ast.dart';
import 'package:app/core/engine/parser/token.dart';
import 'package:app/core/engine_result.dart';
import 'package:app/core/eval_types.dart';

class Binder {
  final SymbolTable _symbols;

  final List<EngineError> _diagnostics = [];
  List<EngineError> get diagnostics => _diagnostics;

  Binder([SymbolTable? symbols]) : _symbols = symbols ?? _createGlobalScope();

  static SymbolTable _createGlobalScope() {
    final scope = SymbolTable();

    // Load definitions dynamically from the Standard Library
    StandardLibrary.allConstants.forEach((name, val) {
      ValueType type = switch (val) {
        NumberValue() => ValueType.number,
        ComplexValue() => ValueType.complex,
        _ => ValueType.any,
      };
      scope.define(name, type, isConstant: true);
    });

    StandardLibrary.allFunctions.forEach((name, fn) {
      scope.define(name, ValueType.function, isConstant: true);
    });

    return scope;
  }

  void defineVariable(String name, ValueType type) {
    _symbols.define(name, type);
  }

  // ... Update _bindUnaryOperator to include percent ...
  BoundUnaryOperator _bindUnaryOperator(TokenType type) {
    return switch (type) {
      TokenType.minus => BoundUnaryOperator.negate,
      TokenType.factorial => BoundUnaryOperator.factorial,
      TokenType.percent => BoundUnaryOperator.percent, // NEW
      _ => throw ArgumentError('Invalid unary operator: $type'),
    };
  }

  BoundNode bind(ASTNode node) {
    // Clear previous diagnostics
    _diagnostics.clear();

    try {
      if (node is Expression) {
        return _bindExpression(node);
      } else if (node is Statement) {
        return _bindStatement(node);
      }
      throw EngineError(
        ErrorType.unknown,
        'Unknown node type: ${node.runtimeType}',
        position: node.position,
      );
    } catch (e) {
      // If it's an EngineError, we can record it.
      // For now, we rethrow because the current Engine structure catches exceptions,
      // but having the diagnostics list ready is good practice for future recovery.
      if (e is EngineError) {
        _diagnostics.add(e);
      }
      rethrow;
    }
  }

  BoundExpression _bindExpression(Expression expr) {
    switch (expr) {
      case NumberLiteral():
        return BoundNumberLiteral(expr.value, expr.position);

      case StringLiteral():
        return BoundStringLiteral(expr.value, expr.position);

      case IdentifierExpression():
        final symbol = _symbols.lookup(expr.name);
        if (symbol == null) {
          throw EngineError(
            ErrorType.undefinedVariable,
            'Undefined variable: ${expr.name}',
            position: expr.position,
            hint: 'Make sure the variable is defined before use',
          );
        }
        return BoundVariable(expr.name, symbol.type, expr.position);

      case BinaryExpression():
        final left = _bindExpression(expr.left);
        final right = _bindExpression(expr.right);
        final op = _bindBinaryOperator(expr.operator);
        final resultType = _inferBinaryType(left.type, op, right.type);
        return BoundBinaryOperation(left, op, right, resultType, expr.position);

      case UnaryExpression():
        final operand = _bindExpression(expr.operand);
        final op = _bindUnaryOperator(expr.operator);
        final resultType = _inferUnaryType(op, operand.type);
        return BoundUnaryOperation(op, operand, resultType, expr.position);

      case CallExpression():
        final args = expr.arguments.map(_bindExpression).toList();
        final symbol = _symbols.lookup(expr.functionName);
        if (symbol == null) {
          throw EngineError(
            ErrorType.undefinedFunction,
            'Undefined function: ${expr.functionName}',
            position: expr.position,
          );
        }
        return BoundFunctionCall(
          expr.functionName,
          args,
          ValueType.any,
          expr.position,
        );

      case RootExpression():
        final radicand = _bindExpression(expr.radicand);
        final index = expr.index != null ? _bindExpression(expr.index!) : null;
        return BoundRoot(radicand, index, expr.position);

      case MatrixLiteral():
        final rows = expr.rows
            .map((row) => row.map(_bindExpression).toList())
            .toList();
        return BoundMatrixLiteral(rows, expr.position);

      case VectorLiteral():
        final components = expr.components.map(_bindExpression).toList();
        return BoundVectorLiteral(components, expr.position);

      case RecordLiteral():
        final fields = expr.fields.map(
          (key, value) => MapEntry(key, _bindExpression(value)),
        );
        return BoundRecordLiteral(fields, expr.position);

      case ListLiteral():
        final elements = expr.elements.map(_bindExpression).toList();
        return BoundListLiteral(elements, expr.position);

      case IfExpression():
        final condition = _bindExpression(expr.condition);
        final thenBranch = _bindExpression(expr.thenBranch);
        final elseBranch = _bindExpression(expr.elseBranch);
        final resultType = _unifyTypes(thenBranch.type, elseBranch.type);
        return BoundIfExpression(
          condition,
          thenBranch,
          elseBranch,
          resultType,
          expr.position,
        );

      default:
        throw EngineError(
          ErrorType.unknown,
          'Unknown expression type: ${expr.runtimeType}',
          position: expr.position,
        );
    }
  }

  BoundStatement _bindStatement(Statement stmt) {
    switch (stmt) {
      case ExpressionStatement():
        BoundExpression expression = _bindExpression(stmt.expression);
        return BoundExpressionStatement(
          expression,
          expression.type,
          expression.position,
        );

      case LetStatement():
        final value = _bindExpression(stmt.value);
        _symbols.define(stmt.name, value.type);
        return BoundLetStatement(stmt.name, value, value.type, stmt.position);

      default:
        throw EngineError(
          ErrorType.unknown,
          'Unknown statement type: ${stmt.runtimeType}',
          position: stmt.position,
        );
    }
  }

  BoundBinaryOperator _bindBinaryOperator(TokenType type) {
    return switch (type) {
      TokenType.plus => BoundBinaryOperator.add,
      TokenType.minus => BoundBinaryOperator.subtract,
      TokenType.multiply => BoundBinaryOperator.multiply,
      TokenType.divide => BoundBinaryOperator.divide,
      TokenType.power => BoundBinaryOperator.power,
      TokenType.equals => BoundBinaryOperator.equals,
      TokenType.notEquals => BoundBinaryOperator.notEquals,
      TokenType.lessThan => BoundBinaryOperator.lessThan,
      TokenType.greaterThan => BoundBinaryOperator.greaterThan,
      TokenType.lessOrEqual => BoundBinaryOperator.lessOrEqual,
      TokenType.greaterOrEqual => BoundBinaryOperator.greaterOrEqual,
      _ => throw ArgumentError('Invalid binary operator: $type'),
    };
  }

  ValueType _inferBinaryType(
    ValueType left,
    BoundBinaryOperator op,
    ValueType right,
  ) {
    if (op == BoundBinaryOperator.add || op == BoundBinaryOperator.subtract) {
      if (left == ValueType.matrix && right == ValueType.matrix)
        return ValueType.matrix;
      if (left == ValueType.vector && right == ValueType.vector)
        return ValueType.vector;
      if (left == ValueType.complex || right == ValueType.complex)
        return ValueType.complex;
      return ValueType.number;
    }
    return ValueType.number;
  }

  ValueType _inferUnaryType(BoundUnaryOperator op, ValueType operandType) =>
      operandType;

  ValueType _unifyTypes(ValueType a, ValueType b) {
    if (a == b) return a;
    if (a == ValueType.any || b == ValueType.any) return ValueType.any;
    return ValueType.any;
  }
}
// ============================================================================
// FILE: core/engine/binder/bound_ast.dart
// Bound AST nodes (after type checking and symbol resolution)
// ============================================================================

import 'package:app/core/engine/binder/symbol_table.dart';

/// Bound nodes have resolved types and symbols
sealed class BoundNode {
  final ValueType type;
  final int position;

  const BoundNode(this.type, this.position);
}

sealed class BoundExpression extends BoundNode {
  const BoundExpression(super.type, super.position);
}

class BoundNumberLiteral extends BoundExpression {
  final double value;

  const BoundNumberLiteral(this.value, int position)
    : super(ValueType.number, position);
}

class BoundStringLiteral extends BoundExpression {
  final String value;

  const BoundStringLiteral(this.value, int position)
    : super(ValueType.string, position);
}

class BoundVariable extends BoundExpression {
  final String name;

  const BoundVariable(this.name, ValueType type, int position)
    : super(type, position);
}

class BoundBinaryOperation extends BoundExpression {
  final BoundExpression left;
  final BoundBinaryOperator operator;
  final BoundExpression right;

  const BoundBinaryOperation(
    this.left,
    this.operator,
    this.right,
    ValueType resultType,
    int position,
  ) : super(resultType, position);
}

enum BoundBinaryOperator {
  add,
  subtract,
  multiply,
  divide,
  power,
  modulo,
  equals,
  notEquals,
  lessThan,
  greaterThan,
  lessOrEqual,
  greaterOrEqual,
}

class BoundUnaryOperation extends BoundExpression {
  final BoundUnaryOperator operator;
  final BoundExpression operand;

  const BoundUnaryOperation(
    this.operator,
    this.operand,
    ValueType resultType,
    int position,
  ) : super(resultType, position);
}

enum BoundUnaryOperator { negate, factorial, absoluteValue, not, percent }

class BoundFunctionCall extends BoundExpression {
  final String functionName;
  final List<BoundExpression> arguments;

  const BoundFunctionCall(
    this.functionName,
    this.arguments,
    ValueType resultType,
    int position,
  ) : super(resultType, position);
}

class BoundRoot extends BoundExpression {
  final BoundExpression? index;
  final BoundExpression radicand;

  const BoundRoot(this.radicand, this.index, int position)
    : super(ValueType.any, position);
}

class BoundMatrixLiteral extends BoundExpression {
  final List<List<BoundExpression>> rows;

  const BoundMatrixLiteral(this.rows, int position)
    : super(ValueType.matrix, position);
}

class BoundVectorLiteral extends BoundExpression {
  final List<BoundExpression> components;

  const BoundVectorLiteral(this.components, int position)
    : super(ValueType.vector, position);
}

class BoundRecordLiteral extends BoundExpression {
  final Map<String, BoundExpression> fields;

  const BoundRecordLiteral(this.fields, int position)
    : super(ValueType.record, position);
}

class BoundListLiteral extends BoundExpression {
  final List<BoundExpression> elements;

  const BoundListLiteral(this.elements, int position)
    : super(ValueType.list, position);
}

class BoundIfExpression extends BoundExpression {
  final BoundExpression condition;
  final BoundExpression thenBranch;
  final BoundExpression elseBranch;

  const BoundIfExpression(
    this.condition,
    this.thenBranch,
    this.elseBranch,
    ValueType resultType,
    int position,
  ) : super(resultType, position);
}

sealed class BoundStatement extends BoundNode {
  const BoundStatement(super.type, super.position);
}

class BoundExpressionStatement extends BoundStatement {
  final BoundExpression expression;

  const BoundExpressionStatement(this.expression, ValueType type, int position)
    : super(type, position);
}

class BoundLetStatement extends BoundStatement {
  final String name;
  final BoundExpression value;

  const BoundLetStatement(this.name, this.value, ValueType type, int position)
    : super(type, position);
}
// ============================================================================
// FILE: core/engine/binder/symbol_table.dart
// Symbol resolution and type checking
// ============================================================================

class Symbol {
  final String name;
  final ValueType type;
  final bool isConstant;

  const Symbol(this.name, this.type, {this.isConstant = false});
}

enum ValueType {
  number,
  complex,
  matrix,
  vector,
  fraction,
  boolean,
  string,
  record,
  list,
  function,
  any,
  unknown,
}

class SymbolTable {
  final SymbolTable? parent;
  final Map<String, Symbol> _symbols = {};

  SymbolTable([this.parent]);

  void define(String name, ValueType type, {bool isConstant = false}) {
    _symbols[name] = Symbol(name, type, isConstant: isConstant);
  }

  Symbol? lookup(String name) {
    return _symbols[name] ?? parent?.lookup(name);
  }

  bool isDefined(String name) => lookup(name) != null;

  SymbolTable createChild() => SymbolTable(this);
}
// ============================================================================
// FILE: core/engine/evaluator/evaluator.dart
// Evaluates Bound AST to produce Values
// ============================================================================

import 'dart:math' as math;

import 'package:app/core/engine/binder/bound_ast.dart';
import 'package:app/core/engine/evaluator/runtime_errors.dart';
import 'package:app/core/engine/library/standard_library.dart';
import 'package:app/core/eval_context.dart';
import 'package:app/core/eval_types.dart';

class Evaluator {
  final Map<String, Value> _variables = {};
  final Map<String, NativeFunction> _builtins = StandardLibrary.allFunctions;

  EvalContext? _currentContext;

  Value evaluate(BoundNode node, [EvalContext? context]) {
    _currentContext = context;

    if (node is BoundExpression) {
      return _evaluateExpression(node);
    } else if (node is BoundStatement) {
      return _evaluateStatement(node);
    }
    throw RuntimeError('Unknown bound node type: ${node.runtimeType}');
  }

  void setVariable(String name, Value value) {
    _variables[name] = value;
  }

  // ADDED: Required by Engine.getVariable()
  Value? getVariable(String name) {
    return _variables[name];
  }

  // ADDED: Required by Engine.clearVariables()
  void clearUserVariables() {
    _variables.clear();
  }

  Value _evaluateExpression(BoundExpression expr) {
    switch (expr) {
      case BoundNumberLiteral():
        return NumberValue(expr.value);

      case BoundStringLiteral():
        return StringValue(expr.value);

      case BoundVariable():
        final value = _variables[expr.name];
        if (value == null) {
          throw RuntimeError('Undefined variable: ${expr.name}');
        }
        return value;

      case BoundBinaryOperation():
        return _evaluateBinaryOp(expr);

      case BoundUnaryOperation():
        return _evaluateUnaryOp(expr);

      case BoundFunctionCall():
        return _evaluateFunctionCall(expr);

      case BoundRoot():
        return _evaluateRoot(expr);

      case BoundMatrixLiteral():
        return _evaluateMatrix(expr);

      case BoundVectorLiteral():
        return _evaluateVector(expr);

      case BoundRecordLiteral():
        return _evaluateRecord(expr);

      case BoundListLiteral():
        final elements = expr.elements.map(_evaluateExpression).toList();
        return ListValue(elements);

      case BoundIfExpression():
        final condition = _evaluateExpression(expr.condition);
        if (_isTruthy(condition)) {
          return _evaluateExpression(expr.thenBranch);
        } else {
          return _evaluateExpression(expr.elseBranch);
        }

      default:
        throw RuntimeError('Unknown expression type: ${expr.runtimeType}');
    }
  }

  Value _evaluateStatement(BoundStatement stmt) {
    switch (stmt) {
      case BoundExpressionStatement():
        return _evaluateExpression(stmt.expression);

      case BoundLetStatement():
        final value = _evaluateExpression(stmt.value);
        _variables[stmt.name] = value;
        return value;

      default:
        throw RuntimeError('Unknown statement type: ${stmt.runtimeType}');
    }
  }

  Value _evaluateBinaryOp(BoundBinaryOperation op) {
    final left = _evaluateExpression(op.left);
    final right = _evaluateExpression(op.right);

    return switch (op.operator) {
      BoundBinaryOperator.add => _add(left, right),
      BoundBinaryOperator.subtract => _subtract(left, right),
      BoundBinaryOperator.multiply => _multiply(left, right),
      BoundBinaryOperator.divide => _divide(left, right),
      BoundBinaryOperator.power => _power(left, right),
      BoundBinaryOperator.modulo => _modulo(left, right),
      BoundBinaryOperator.equals => BooleanValue(_equals(left, right)),
      BoundBinaryOperator.notEquals => BooleanValue(!_equals(left, right)),
      BoundBinaryOperator.lessThan => _compare(left, right, (a, b) => a < b),
      BoundBinaryOperator.greaterThan => _compare(left, right, (a, b) => a > b),
      BoundBinaryOperator.lessOrEqual => _compare(
        left,
        right,
        (a, b) => a <= b,
      ),
      BoundBinaryOperator.greaterOrEqual => _compare(
        left,
        right,
        (a, b) => a >= b,
      ),
    };
  }

  Value _add(Value a, Value b) {
    if (a is NumberValue && b is NumberValue)
      return NumberValue(a.value + b.value);
    if (a is ComplexValue || b is ComplexValue) {
      final ca = _toComplex(a);
      final cb = _toComplex(b);
      return ComplexValue(ca.real + cb.real, ca.imaginary + cb.imaginary);
    }
    if (a is MatrixValue && b is MatrixValue) return _addMatrices(a, b);
    if (a is VectorValue && b is VectorValue) return _addVectors(a, b);
    throw RuntimeError('Cannot add ${a.runtimeType} and ${b.runtimeType}');
  }

  Value _subtract(Value a, Value b) {
    if (a is NumberValue && b is NumberValue)
      return NumberValue(a.value - b.value);
    if (a is ComplexValue || b is ComplexValue) {
      final ca = _toComplex(a);
      final cb = _toComplex(b);
      return ComplexValue(ca.real - cb.real, ca.imaginary - cb.imaginary);
    }
    throw RuntimeError('Cannot subtract ${a.runtimeType} and ${b.runtimeType}');
  }

  Value _multiply(Value a, Value b) {
    if (a is NumberValue && b is NumberValue)
      return NumberValue(a.value * b.value);
    if (a is ComplexValue || b is ComplexValue) {
      final ca = _toComplex(a);
      final cb = _toComplex(b);
      return ComplexValue(
        ca.real * cb.real - ca.imaginary * cb.imaginary,
        ca.real * cb.imaginary + ca.imaginary * cb.real,
      );
    }
    if (a is MatrixValue && b is MatrixValue) return _multiplyMatrices(a, b);
    throw RuntimeError('Cannot multiply ${a.runtimeType} and ${b.runtimeType}');
  }

  Value _divide(Value a, Value b) {
    if (a is NumberValue && b is NumberValue) {
      if (b.value == 0) throw RuntimeError('Division by zero');
      return NumberValue(a.value / b.value);
    }
    if (a is ComplexValue || b is ComplexValue) {
      final ca = _toComplex(a);
      final cb = _toComplex(b);
      final denom = cb.real * cb.real + cb.imaginary * cb.imaginary;
      return ComplexValue(
        (ca.real * cb.real + ca.imaginary * cb.imaginary) / denom,
        (ca.imaginary * cb.real - ca.real * cb.imaginary) / denom,
      );
    }
    throw RuntimeError('Cannot divide ${a.runtimeType} by ${b.runtimeType}');
  }

  Value _power(Value a, Value b) {
    if (a is NumberValue && b is NumberValue) {
      return NumberValue(math.pow(a.value, b.value).toDouble());
    }
    throw RuntimeError(
      'Cannot raise ${a.runtimeType} to power of ${b.runtimeType}',
    );
  }

  Value _modulo(Value a, Value b) {
    if (a is NumberValue && b is NumberValue) {
      return NumberValue(a.value % b.value);
    }
    throw RuntimeError(
      'Cannot take modulo of ${a.runtimeType} and ${b.runtimeType}',
    );
  }

  Value _evaluateUnaryOp(BoundUnaryOperation op) {
    final operand = _evaluateExpression(op.operand);
    return switch (op.operator) {
      BoundUnaryOperator.negate => _negate(operand),
      BoundUnaryOperator.factorial => _factorial(operand),
      BoundUnaryOperator.absoluteValue => _absolute(operand),
      BoundUnaryOperator.not => BooleanValue(!_isTruthy(operand)),
      BoundUnaryOperator.percent => _percent(operand),
    };
  }

  Value _percent(Value v) {
    if (v is NumberValue) return NumberValue(v.value / 100.0);
    throw RuntimeError('Percentage requires a number');
  }

  Value _negate(Value v) {
    if (v is NumberValue) return NumberValue(-v.value);
    if (v is ComplexValue) return ComplexValue(-v.real, -v.imaginary);
    throw RuntimeError('Cannot negate ${v.runtimeType}');
  }

  Value _factorial(Value v) {
    if (v is! NumberValue) throw RuntimeError('Factorial requires a number');
    final n = v.value.toInt();
    if (n < 0 || n != v.value)
      throw RuntimeError('Factorial requires non-negative integer');

    int result = 1;
    for (int i = 2; i <= n; i++) result *= i;
    return NumberValue(result.toDouble());
  }

  Value _absolute(Value v) {
    if (v is NumberValue) return NumberValue(v.value.abs());
    if (v is ComplexValue) {
      final mag = math.sqrt(v.real * v.real + v.imaginary * v.imaginary);
      return NumberValue(mag);
    }
    throw RuntimeError('Cannot take absolute value of ${v.runtimeType}');
  }

  Value _evaluateFunctionCall(BoundFunctionCall call) {
    final fn = _builtins[call.functionName];
    if (fn == null) {
      throw RuntimeError('Unknown function: ${call.functionName}');
    }

    final args = call.arguments.map(_evaluateExpression).toList();
    if (args.length != fn.arity) {
      throw RuntimeError(
        '${call.functionName} expects ${fn.arity} arguments, got ${args.length}',
      );
    }

    return fn.execute(args);
  }

  Value _evaluateRoot(BoundRoot root) {
    final radicand = _evaluateExpression(root.radicand);
    final index = root.index != null
        ? _evaluateExpression(root.index!) as NumberValue
        : NumberValue(2);

    if (radicand is! NumberValue) {
      throw RuntimeError('Root requires numeric radicand');
    }

    final n = index.value;
    final x = radicand.value;

    if (n == 0) throw RuntimeError('0th root is undefined');

    if (x < 0 && n % 2 == 0) {
      return ComplexValue(0, math.pow(x.abs(), 1 / n).toDouble());
    }

    return NumberValue(math.pow(x, 1 / n).toDouble());
  }

  Value _evaluateMatrix(BoundMatrixLiteral mat) {
    final data = mat.rows.map((row) {
      return row.map((e) {
        final v = _evaluateExpression(e);
        if (v is! NumberValue)
          throw RuntimeError('Matrix elements must be numbers');
        return v.value;
      }).toList();
    }).toList();
    return MatrixValue(data);
  }

  Value _evaluateVector(BoundVectorLiteral vec) {
    final components = vec.components.map((e) {
      final v = _evaluateExpression(e);
      if (v is! NumberValue)
        throw RuntimeError('Vector components must be numbers');
      return v.value;
    }).toList();
    return VectorValue(components);
  }

  Value _evaluateRecord(BoundRecordLiteral rec) {
    final fields = rec.fields.map(
      (key, value) => MapEntry(key, _evaluateExpression(value)),
    );
    return RecordValue(fields);
  }

  // ... (Matrix/Vector/Complex helpers _toComplex, _addMatrices, etc. remain unchanged) ...
  ComplexValue _toComplex(Value v) {
    if (v is ComplexValue) return v;
    if (v is NumberValue) return ComplexValue(v.value, 0);
    throw RuntimeError('Cannot convert ${v.runtimeType} to complex');
  }

  MatrixValue _addMatrices(MatrixValue a, MatrixValue b) {
    if (a.rows != b.rows || a.cols != b.cols) {
      throw RuntimeError('Matrix dimensions must match for addition');
    }
    final result = List.generate(
      a.rows,
      (i) => List.generate(a.cols, (j) => a.data[i][j] + b.data[i][j]),
    );
    return MatrixValue(result);
  }

  VectorValue _addVectors(VectorValue a, VectorValue b) {
    if (a.dimension != b.dimension) {
      throw RuntimeError('Vector dimensions must match');
    }
    final result = List.generate(
      a.dimension,
      (i) => a.components[i] + b.components[i],
    );
    return VectorValue(result);
  }

  MatrixValue _multiplyMatrices(MatrixValue a, MatrixValue b) {
    if (a.cols != b.rows) {
      throw RuntimeError('Invalid matrix dimensions for multiplication');
    }
    final result = List.generate(a.rows, (i) {
      return List.generate(b.cols, (j) {
        double sum = 0;
        for (int k = 0; k < a.cols; k++) {
          sum += a.data[i][k] * b.data[k][j];
        }
        return sum;
      });
    });
    return MatrixValue(result);
  }

  bool _equals(Value a, Value b) {
    if (a is NumberValue && b is NumberValue) return a.value == b.value;
    if (a is BooleanValue && b is BooleanValue) return a.value == b.value;
    if (a is StringValue && b is StringValue) return a.value == b.value;
    return false;
  }

  BooleanValue _compare(Value a, Value b, bool Function(double, double) op) {
    if (a is! NumberValue || b is! NumberValue) {
      throw RuntimeError('Comparison requires numbers');
    }
    return BooleanValue(op(a.value, b.value));
  }

  bool _isTruthy(Value v) {
    if (v is BooleanValue) return v.value;
    if (v is NumberValue) return v.value != 0;
    return true;
  }
}

class NativeFunction {
  final int arity;
  final Value Function(List<Value>) execute;

  const NativeFunction(this.arity, this.execute);
}
// ============================================================================
// FILE: core/engine/evaluator/runtime_errors.dart
// ============================================================================

class RuntimeError extends Error {
  final String message;
  RuntimeError(this.message);

  @override
  String toString() => 'Runtime Error: $message';
}
import 'dart:math' as math;

import 'package:app/core/engine/evaluator/evaluator.dart';
import 'package:app/core/engine/library/library_module.dart';
import 'package:app/core/eval_types.dart';

/// The basic math functions (sin, cos, log, etc.)
class CoreMathModule extends LibraryModule {
  @override
  Map<String, Value> get constants => {
    'pi': NumberValue(math.pi),
    'e': NumberValue(math.e),
    'i': const ComplexValue(0, 1),
  };

  @override
  Map<String, NativeFunction> get functions => {
    'sin': NativeFunction(
      1,
      (args) => NumberValue(math.sin(args[0].toDouble() ?? 0)),
    ),
    'cos': NativeFunction(
      1,
      (args) => NumberValue(math.cos(args[0].toDouble() ?? 0)),
    ),
    'tan': NativeFunction(
      1,
      (args) => NumberValue(math.tan(args[0].toDouble() ?? 0)),
    ),
    'sqrt': NativeFunction(1, (args) {
      double val = args[0].toDouble() ?? 0;
      if (val < 0) return ComplexValue(0, math.sqrt(-val));
      return NumberValue(math.sqrt(val));
    }),
    'ln': NativeFunction(
      1,
      (args) => NumberValue(math.log(args[0].toDouble() ?? 0)),
    ),
    'log': NativeFunction(
      1,
      (args) => NumberValue(math.log(args[0].toDouble() ?? 0) / math.ln10),
    ),
    'abs': NativeFunction(1, (args) {
      final val = args[0];
      if (val is NumberValue) return NumberValue(val.value.abs());
      if (val is ComplexValue)
        return NumberValue(
          math.sqrt(val.real * val.real + val.imaginary * val.imaginary),
        );
      return val;
    }),
  };
}
import 'dart:math' as math;
import 'package:app/core/eval_types.dart';
import 'package:app/core/engine/evaluator/evaluator.dart'; // For NativeFunction
import 'package:app/core/engine/evaluator/evaluator.dart';
import 'package:app/core/eval_types.dart';

abstract class LibraryModule {
  Map<String, NativeFunction> get functions;
  Map<String, Value> get constants;
}
import 'package:app/core/engine/evaluator/evaluator.dart';
import 'package:app/core/engine/library/core_math_module.dart';
import 'package:app/core/engine/library/library_module.dart';
import 'package:app/core/eval_types.dart';

/// Defines a module of functions (e.g., Geometry, Finance, Core)
class StandardLibrary {
  static final List<LibraryModule> _modules = [
    CoreMathModule(),
    // Future: GeometryModule(),
    // Future: FinanceModule(),
  ];

  /// Aggregates all functions from all modules
  static Map<String, NativeFunction> get allFunctions {
    final map = <String, NativeFunction>{};
    for (var module in _modules) {
      map.addAll(module.functions);
    }
    return map;
  }

  /// Aggregates all constants
  static Map<String, Value> get allConstants {
    final map = <String, Value>{};
    for (var module in _modules) {
      map.addAll(module.constants);
    }
    return map;
  }
}
import 'package:app/core/engine/parser/token.dart';

/// Base class for all AST nodes
sealed class ASTNode {
  final int position;
  const ASTNode(this.position);
}

// Expressions
sealed class Expression extends ASTNode {
  const Expression(super.position);
}

class NumberLiteral extends Expression {
  final double value;
  const NumberLiteral(this.value, int position) : super(position);
}

class StringLiteral extends Expression {
  final String value;
  const StringLiteral(this.value, int position) : super(position);
}

class IdentifierExpression extends Expression {
  final String name;
  const IdentifierExpression(this.name, int position) : super(position);
}

class BinaryExpression extends Expression {
  final Expression left;
  final TokenType operator;
  final Expression right;

  const BinaryExpression(this.left, this.operator, this.right, int position)
    : super(position);
}

class UnaryExpression extends Expression {
  final TokenType operator;
  final Expression operand;

  const UnaryExpression(this.operator, this.operand, int position)
    : super(position);
}

class CallExpression extends Expression {
  final String functionName;
  final List<Expression> arguments;

  const CallExpression(this.functionName, this.arguments, int position)
    : super(position);
}

class RootExpression extends Expression {
  final Expression? index;
  final Expression radicand;

  // FIX: position is now passed explicitly to super
  const RootExpression(this.radicand, this.index, int position)
    : super(position);
}

class MatrixLiteral extends Expression {
  final List<List<Expression>> rows;
  const MatrixLiteral(this.rows, int position) : super(position);
}

class VectorLiteral extends Expression {
  final List<Expression> components;
  const VectorLiteral(this.components, int position) : super(position);
}

class RecordLiteral extends Expression {
  final Map<String, Expression> fields;
  const RecordLiteral(this.fields, int position) : super(position);
}

class ListLiteral extends Expression {
  final List<Expression> elements;
  const ListLiteral(this.elements, int position) : super(position);
}

class IfExpression extends Expression {
  final Expression condition;
  final Expression thenBranch;
  final Expression elseBranch;

  const IfExpression(
    this.condition,
    this.thenBranch,
    this.elseBranch,
    int position,
  ) : super(position);
}

// Statements
sealed class Statement extends ASTNode {
  const Statement(super.position);
}

class ExpressionStatement extends Statement {
  final Expression expression;
  // FIX: explicit position parameter
  const ExpressionStatement(this.expression, int position) : super(position);
}

class LetStatement extends Statement {
  final String name;
  final Expression value;

  const LetStatement(this.name, this.value, int position) : super(position);
}

class FunctionDeclaration extends Statement {
  final String name;
  final List<String> parameters;
  final Expression body;

  const FunctionDeclaration(this.name, this.parameters, this.body, int position)
    : super(position);
}
// ============================================================================
// FILE: core/engine/parser/parser.dart
// Converts List<Token> → AST (recursive descent parser)
// ============================================================================

import 'package:app/core/engine/parser/ast.dart';
import 'package:app/core/engine/parser/token.dart';
import 'package:app/core/engine_result.dart';

class Parser {
  final List<Token> tokens;
  int _current = 0;

  Parser(this.tokens);

  /// Parse a single statement or expression
  ASTNode parse() {
    try {
      return _statement();
    } catch (e) {
      throw EngineError(
        ErrorType.invalidSyntax,
        e.toString(),
        position: _peek().position,
      );
    }
  }

  Statement _statement() {
    if (_match(TokenType.let)) return _letStatement();
    Expression expression = _expression();
    return ExpressionStatement(expression, expression.position);
  }

  LetStatement _letStatement() {
    final name = _consume(TokenType.identifier, 'Expected variable name');
    _consume(TokenType.equals, 'Expected = after variable name');
    final value = _expression();
    return LetStatement(name.lexeme, value, name.position);
  }

  Expression _expression() => _assignment();

  Expression _assignment() {
    final expr = _comparison();
    // Future: handle assignment operators
    return expr;
  }

  Expression _comparison() {
    var expr = _additive();

    while (_match(
      TokenType.equals,
      TokenType.notEquals,
      TokenType.lessThan,
      TokenType.greaterThan,
      TokenType.lessOrEqual,
      TokenType.greaterOrEqual,
    )) {
      final operator = _previous().type;
      final right = _additive();
      expr = BinaryExpression(expr, operator, right, expr.position);
    }

    return expr;
  }

  Expression _additive() {
    var expr = _multiplicative();

    while (_match(TokenType.plus, TokenType.minus)) {
      final operator = _previous().type;
      final right = _multiplicative();
      expr = BinaryExpression(expr, operator, right, expr.position);
    }

    return expr;
  }

  Expression _multiplicative() {
    var expr = _implicitMultiplication();

    while (_match(TokenType.multiply, TokenType.divide)) {
      final operator = _previous().type;
      final right = _implicitMultiplication();
      expr = BinaryExpression(expr, operator, right, expr.position);
    }

    return expr;
  }

  Expression _implicitMultiplication() {
    var expr = _power();

    // Handle implicit multiplication: 2x, 3(x+1), (x+1)(x-1)
    while (_canImplicitMultiply()) {
      final right = _power();
      expr = BinaryExpression(expr, TokenType.multiply, right, expr.position);
    }

    return expr;
  }

  bool _canImplicitMultiply() {
    final current = _peek().type;
    final previous = _current > 0 ? tokens[_current - 1].type : null;

    // After number or ) or ], before ( or identifier
    return (previous == TokenType.number ||
            previous == TokenType.rightParen ||
            previous == TokenType.rightBracket) &&
        (current == TokenType.leftParen ||
            current == TokenType.identifier ||
            current == TokenType.root);
  }

  Expression _power() {
    var expr = _postfix();

    if (_match(TokenType.power)) {
      final right = _power(); // Right associative
      expr = BinaryExpression(expr, TokenType.power, right, expr.position);
    }

    return expr;
  }

  Expression _postfix() {
    var expr = _unary();

    while (true) {
      if (_match(TokenType.factorial)) {
        expr = UnaryExpression(TokenType.factorial, expr, _previous().position);
      } else if (_match(TokenType.percent)) {
        expr = UnaryExpression(TokenType.percent, expr, _previous().position);
      } else {
        break;
      }
    }

    return expr;
  }

  Expression _unary() {
    if (_match(TokenType.minus, TokenType.plus)) {
      final operator = _previous().type;
      final operand = _unary();
      return UnaryExpression(
        operator,
        operand,
        operator == TokenType.minus ? _previous().position : operand.position,
      );
    }

    return _root();
  }

  Expression _root() {
    if (_match(TokenType.root)) {
      final rootPos = _previous().position;

      // Check for index before root (e.g., 3√8)
      Expression? index;
      if (_current > 1 && tokens[_current - 2].type == TokenType.number) {
        // Already consumed, need to backtrack
        // For simplicity, require explicit nthrt() function for custom roots
      }

      final radicand = _call();
      return RootExpression(radicand, index, rootPos);
    }

    return _call();
  }

  Expression _call() {
    var expr = _primary();

    if (expr is IdentifierExpression && _match(TokenType.leftParen)) {
      final args = _arguments();
      _consume(TokenType.rightParen, 'Expected ) after arguments');
      expr = CallExpression(expr.name, args, expr.position);
    }

    return expr;
  }

  List<Expression> _arguments() {
    final args = <Expression>[];

    if (_peek().type == TokenType.rightParen) return args;

    do {
      args.add(_expression());
    } while (_match(TokenType.comma));

    return args;
  }

  Expression _primary() {
    if (_match(TokenType.number)) {
      final token = _previous();
      return NumberLiteral(token.literal as double, token.position);
    }

    if (_match(TokenType.string)) {
      final token = _previous();
      return StringLiteral(token.literal as String, token.position);
    }

    if (_match(TokenType.identifier)) {
      final token = _previous();
      return IdentifierExpression(token.lexeme, token.position);
    }

    if (_match(TokenType.imaginaryUnit)) {
      return NumberLiteral(0, _previous().position); // Will be bound to i
    }

    if (_match(TokenType.leftParen)) {
      final expr = _expression();
      _consume(TokenType.rightParen, 'Expected ) after expression');
      return expr;
    }

    if (_match(TokenType.leftBracket)) {
      return _matrixOrVector();
    }

    if (_match(TokenType.leftBrace)) {
      return _recordLiteral();
    }

    throw EngineError(
      ErrorType.unexpectedToken,
      'Unexpected token: ${_peek().lexeme}',
      position: _peek().position,
    );
  }

  Expression _matrixOrVector() {
    final rows = <List<Expression>>[];
    var currentRow = <Expression>[];

    if (_peek().type == TokenType.rightBracket) {
      _advance();
      return VectorLiteral([], _previous().position);
    }

    do {
      currentRow.add(_expression());

      if (_match(TokenType.semicolon)) {
        rows.add(currentRow);
        currentRow = <Expression>[];
      } else if (_match(TokenType.comma)) {
        continue;
      }
    } while (!_check(TokenType.rightBracket));

    _consume(TokenType.rightBracket, 'Expected ]');

    if (currentRow.isNotEmpty) rows.add(currentRow);

    // Determine if matrix or vector
    if (rows.length == 1) {
      return VectorLiteral(rows[0], rows[0][0].position);
    } else {
      return MatrixLiteral(rows, rows[0][0].position);
    }
  }

  Expression _recordLiteral() {
    final fields = <String, Expression>{};

    while (!_check(TokenType.rightBrace)) {
      final name = _consume(TokenType.identifier, 'Expected field name');
      _consume(TokenType.colon, 'Expected : after field name');
      final value = _expression();
      fields[name.lexeme] = value;

      if (!_match(TokenType.comma)) break;
    }

    _consume(TokenType.rightBrace, 'Expected }');
    return RecordLiteral(fields, fields.values.first.position);
  }

  bool _match(
    TokenType type, [
    TokenType? type2,
    TokenType? type3,
    TokenType? type4,
    TokenType? type5,
    TokenType? type6,
  ]) {
    if (_check(type)) {
      _advance();
      return true;
    }
    if (type2 != null && _check(type2)) {
      _advance();
      return true;
    }
    if (type3 != null && _check(type3)) {
      _advance();
      return true;
    }
    if (type4 != null && _check(type4)) {
      _advance();
      return true;
    }
    if (type5 != null && _check(type5)) {
      _advance();
      return true;
    }
    if (type6 != null && _check(type6)) {
      _advance();
      return true;
    }
    return false;
  }

  bool _check(TokenType type) {
    if (_isAtEnd()) return false;
    return _peek().type == type;
  }

  Token _advance() {
    if (!_isAtEnd()) _current++;
    return _previous();
  }

  bool _isAtEnd() => _peek().type == TokenType.eof;
  Token _peek() => tokens[_current];
  Token _previous() => tokens[_current - 1];

  Token _consume(TokenType type, String message) {
    if (_check(type)) return _advance();
    throw EngineError(
      ErrorType.unexpectedToken,
      message,
      position: _peek().position,
    );
  }
}
// ============================================================================
// FILE: core/engine/parser/token.dart
// Token types - these rarely change
// ============================================================================

enum TokenType {
  // Literals
  number,
  identifier,
  string,

  // Operators
  plus,
  minus,
  multiply,
  divide,
  power,
  factorial,
  percent,

  // Comparison (for future conditionals)
  equals,
  notEquals,
  lessThan,
  greaterThan,
  lessOrEqual,
  greaterOrEqual,

  // Delimiters
  leftParen,
  rightParen,
  leftBracket,
  rightBracket,
  leftBrace,
  rightBrace,
  comma,
  semicolon,
  colon,

  // Keywords (for future features)
  let,
  if_,
  then,
  else_,
  for_,
  in_,

  // Special
  root, // √
  imaginaryUnit, // i

  eof,
}

class Token {
  final TokenType type;
  final String lexeme;
  final int position;
  final dynamic literal; // For number tokens

  const Token(this.type, this.lexeme, this.position, {this.literal});

  @override
  String toString() => 'Token($type, "$lexeme", $position)';
}
// ============================================================================
// FILE: core/engine/parser/tokenizer.dart
// Converts string → List<Token>
// ============================================================================

import 'package:app/core/engine/parser/token.dart';

class Tokenizer {
  final String input;
  int _current = 0;

  Tokenizer(this.input);

  List<Token> tokenize() {
    final tokens = <Token>[];

    while (!_isAtEnd()) {
      _skipWhitespace();
      if (_isAtEnd()) break;

      final token = _scanToken();
      if (token != null) tokens.add(token);
    }

    tokens.add(Token(TokenType.eof, '', _current));
    return tokens;
  }

  Token? _scanToken() {
    final start = _current;
    final c = _advance();

    // Single character tokens
    switch (c) {
      case '+':
        return Token(TokenType.plus, c, start);
      case '-':
        return Token(TokenType.minus, c, start);
      case '*':
        return Token(TokenType.multiply, c, start);
      case '/':
        return Token(TokenType.divide, c, start);
      case '^':
        return Token(TokenType.power, c, start);
      case '%':
        return Token(TokenType.percent, c, start);
      case '!':
        return Token(TokenType.factorial, c, start);
      case '(':
        return Token(TokenType.leftParen, c, start);
      case ')':
        return Token(TokenType.rightParen, c, start);
      case '[':
        return Token(TokenType.leftBracket, c, start);
      case ']':
        return Token(TokenType.rightBracket, c, start);
      case '{':
        return Token(TokenType.leftBrace, c, start);
      case '}':
        return Token(TokenType.rightBrace, c, start);
      case ',':
        return Token(TokenType.comma, c, start);
      case ';':
        return Token(TokenType.semicolon, c, start);
      case ':':
        return Token(TokenType.colon, c, start);
      case '√':
        return Token(TokenType.root, c, start);
    }

    // Numbers
    if (_isDigit(c)) return _number(start);

    // Identifiers and keywords
    if (_isAlpha(c)) return _identifier(start);

    // String literals
    if (c == '"' || c == "'") return _string(start, c);

    return null; // Skip unknown characters
  }

  Token _number(int start) {
    while (_isDigit(_peek())) _advance();

    // Decimal point
    if (_peek() == '.' && _isDigit(_peekNext())) {
      _advance(); // consume '.'
      while (_isDigit(_peek())) _advance();
    }

    // Scientific notation
    if (_peek() == 'e' || _peek() == 'E') {
      _advance();
      if (_peek() == '+' || _peek() == '-') _advance();
      while (_isDigit(_peek())) _advance();
    }

    final lexeme = input.substring(start, _current);
    final value = double.parse(lexeme);
    return Token(TokenType.number, lexeme, start, literal: value);
  }

  Token _identifier(int start) {
    while (_isAlphaNumeric(_peek())) _advance();

    final lexeme = input.substring(start, _current);

    // Check for keywords
    final type = switch (lexeme) {
      'let' => TokenType.let,
      'if' => TokenType.if_,
      'then' => TokenType.then,
      'else' => TokenType.else_,
      'for' => TokenType.for_,
      'in' => TokenType.in_,
      'i' => TokenType.imaginaryUnit,
      _ => TokenType.identifier,
    };

    return Token(type, lexeme, start);
  }

  Token _string(int start, String quote) {
    while (_peek() != quote && !_isAtEnd()) _advance();

    if (_isAtEnd()) {
      throw Exception('Unterminated string at position $start');
    }

    _advance(); // closing quote
    final value = input.substring(start + 1, _current - 1);
    return Token(TokenType.string, value, start, literal: value);
  }

  void _skipWhitespace() {
    while (!_isAtEnd() && _peek().trim().isEmpty) _advance();
  }

  String _advance() => input[_current++];
  String _peek() => _isAtEnd() ? '\x00' : input[_current];
  String _peekNext() =>
      _current + 1 >= input.length ? '\x00' : input[_current + 1];
  bool _isAtEnd() => _current >= input.length;
  bool _isDigit(String c) => c.codeUnitAt(0) >= 48 && c.codeUnitAt(0) <= 57;
  bool _isAlpha(String c) {
    final code = c.codeUnitAt(0);
    return (code >= 65 && code <= 90) ||
        (code >= 97 && code <= 122) ||
        c == '_';
  }

  bool _isAlphaNumeric(String c) => _isAlpha(c) || _isDigit(c);
}
import 'package:app/core/engine/binder/binder.dart';
import 'package:app/core/engine/evaluator/evaluator.dart';
import 'package:app/core/engine/evaluator/runtime_errors.dart';
import 'package:app/core/engine/parser/parser.dart';
import 'package:app/core/engine/parser/tokenizer.dart';
import 'package:app/core/engine_result.dart';
import 'package:app/core/eval_context.dart';
import 'package:app/core/eval_types.dart';

/// The public API for the calculation engine.
///
/// The UI should interact ONLY with this class. It manages:
/// 1. The persistent state (variables 'A', 'B', 'Ans', etc.)
/// 2. Global settings (Angle Mode, Precision)
/// 3. The execution pipeline (Tokenizer -> Parser -> Binder -> Evaluator)
class EvaluationEngine {
  /// Configuration for the engine (RAD/DEG, precision, etc.)

  // Persistent subsystems
  late final Binder _binder;
  late final Evaluator _evaluator;

  EvaluationEngine() {
    _binder = Binder();
    _evaluator = Evaluator();
  }

  /// The main entry point for calculating a result.
  ///
  /// [input] is the raw string from the text field.
  EngineResult evaluate(String input, EvalContext context) {
    if (input.trim().isEmpty) {
      return EngineSuccess(NumberValue(0), context);
    }

    try {
      // -----------------------------------------------------------------------
      // STEP 1: TOKENIZATION
      // Convert raw text into a stream of meaningful tokens
      // -----------------------------------------------------------------------
      final tokenizer = Tokenizer(input);
      final tokens = tokenizer.tokenize();

      // -----------------------------------------------------------------------
      // STEP 2: PARSING
      // Organize tokens into a structural tree (AST)
      // -----------------------------------------------------------------------
      final parser = Parser(tokens);
      final ast = parser.parse();

      // -----------------------------------------------------------------------
      // STEP 3: BINDING (Semantic Analysis)
      // verify variable names, check types, link symbols to the Registry
      // -----------------------------------------------------------------------
      final boundProgram = _binder.bind(ast);

      // Check for semantic errors (e.g., "Unknown variable 'x'")
      if (_binder.diagnostics.isNotEmpty) {
        return EngineError(
          ErrorType.unknown,
          _binder.diagnostics.first.message,
        );
      }

      // -----------------------------------------------------------------------
      // STEP 4: EVALUATION
      // Execute the bound tree to get a final value
      // -----------------------------------------------------------------------
      final value = _evaluator.evaluate(boundProgram, context);

      // -----------------------------------------------------------------------
      // STEP 5: STATE UPDATE
      // Update 'Ans' variable for the next calculation
      // -----------------------------------------------------------------------
      _evaluator.setVariable('Ans', value);

      return EngineSuccess(value, context);
    } on RuntimeError catch (e) {
      // Logic errors (Divide by zero, etc.)
      return EngineError(ErrorType.runtime, e.message);
    } catch (e) {
      // Unexpected or syntax errors
      return EngineError(ErrorType.invalidSyntax, e.toString());
    }
  }

  /// Manually set a variable (e.g., storing a value in memory 'A')
  void setVariable(String name, Value value) {
    // We update both Binder (so it knows the name exists)
    // and Evaluator (so it knows the value)
    _binder.defineVariable(name, value.type());
    _evaluator.setVariable(name, value);
  }

  /// Get the current value of a variable (e.g., for displaying memory)
  Value? getVariable(String name) {
    return _evaluator.getVariable(name);
  }

  /// Clear all user-defined variables (keeps 'Ans' and system constants)
  void clearVariables() {
    _evaluator.clearUserVariables();
    // Note: Binder might need a reset if we support deleting vars,
    // but for a calculator, types usually persist or we just re-bind.
  }
}
// ============================================================================
// FILE: core/engine_result.dart
// Result types for the entire engine
// ============================================================================

import 'package:app/core/eval_context.dart';
import 'package:app/core/eval_types.dart';

sealed class EngineResult {
  const EngineResult();
}

class EngineSuccess extends EngineResult {
  final Value value;
  final EvalContext context; // Updated context with new variables

  const EngineSuccess(this.value, this.context);
}

class EngineError extends EngineResult {
  final ErrorType type;
  final String message;
  final int? position; // Character position in input
  final String? hint; // Helpful suggestion

  const EngineError(this.type, this.message, {this.position, this.hint});

  @override
  String toString() {
    final buf = StringBuffer('Error: $message');
    if (position != null) buf.write(' at position $position');
    if (hint != null) buf.write('\nHint: $hint');
    return buf.toString();
  }
}

enum ErrorType {
  // Parse errors
  unexpectedToken,
  unexpectedEndOfInput,
  invalidSyntax,

  // Binding errors
  undefinedVariable,
  undefinedFunction,
  typeMismatch,
  wrongArgumentCount,

  // Runtime errors
  divisionByZero,
  domainError,
  dimensionMismatch,
  overflow,
  recursionLimit,

  // General
  unknown,
  runtime,
}
// ============================================================================
// FILE: core/eval_context.dart
// Runtime context (variables, functions, settings)
// ============================================================================

import 'package:app/core/eval_types.dart';

enum AngleMode { radians, degrees }

enum BaseMode { decimal, binary, octal, hexadecimal }

enum DisplayMode { normal, engineering, scientific }

class EvalContext {
  final Map<String, Value> variables;
  final Map<String, FunctionDefinition> functions;
  final AngleMode angleMode;
  final BaseMode baseMode;
  final DisplayMode displayMode;
  final bool exactMode; // Use fractions when possible

  const EvalContext({
    this.variables = const {},
    this.functions = const {},
    this.angleMode = AngleMode.radians,
    this.baseMode = BaseMode.decimal,
    this.displayMode = DisplayMode.normal,
    this.exactMode = false,
  });

  EvalContext copyWith({
    Map<String, Value>? variables,
    Map<String, FunctionDefinition>? functions,
    AngleMode? angleMode,
    BaseMode? baseMode,
    DisplayMode? displayMode,
    bool? exactMode,
  }) {
    return EvalContext(
      variables: variables ?? this.variables,
      functions: functions ?? this.functions,
      angleMode: angleMode ?? this.angleMode,
      baseMode: baseMode ?? this.baseMode,
      displayMode: displayMode ?? this.displayMode,
      exactMode: exactMode ?? this.exactMode,
    );
  }
}

class FunctionDefinition {
  final List<String> parameters;
  final dynamic body; // Can be AST node or native function
  final bool isNative;

  const FunctionDefinition(this.parameters, this.body, {this.isNative = false});
}
// ============================================================================
// FILE: core/eval_types.dart
// Core type definitions that won't change
// ============================================================================

import 'package:app/core/engine/binder/symbol_table.dart';

/// Represents all possible value types in the calculator
sealed class Value {
  const Value();

  /// Convert to display string
  String toDisplayString();

  /// Convert to double if possible (for compatibility)
  double? toDouble();

  ValueType type();
}

class NumberValue extends Value {
  final double value;
  const NumberValue(this.value);

  @override
  String toDisplayString() => value.toString();

  @override
  double toDouble() => value;

  @override
  ValueType type() {
    return ValueType.number;
  }
}

class ComplexValue extends Value {
  final double real;
  final double imaginary;
  const ComplexValue(this.real, this.imaginary);

  @override
  String toDisplayString() {
    if (imaginary.abs() < 1e-10) return real.toStringAsFixed(4);
    if (real.abs() < 1e-10) return '${imaginary.toStringAsFixed(4)}i';
    final sign = imaginary >= 0 ? '+' : '-';
    return '${real.toStringAsFixed(4)}$sign${imaginary.abs().toStringAsFixed(4)}i';
  }

  @override
  double? toDouble() => imaginary.abs() < 1e-10 ? real : null;

  @override
  ValueType type() {
    return ValueType.complex;
  }
}

class MatrixValue extends Value {
  final List<List<double>> data;
  final int rows;
  final int cols;

  MatrixValue(this.data)
    : rows = data.length,
      cols = data.isEmpty ? 0 : data[0].length;

  @override
  String toDisplayString() {
    return data.map((row) => '[${row.join(', ')}]').join('\n');
  }

  @override
  double? toDouble() => rows == 1 && cols == 1 ? data[0][0] : null;

  @override
  ValueType type() {
    return ValueType.matrix;
  }
}

class VectorValue extends Value {
  final List<double> components;
  const VectorValue(this.components);

  int get dimension => components.length;

  @override
  String toDisplayString() {
    return '(${components.map((c) => c.toStringAsFixed(4)).join(', ')})';
  }

  @override
  double? toDouble() => null;

  @override
  ValueType type() {
    return ValueType.vector;
  }
}

class FractionValue extends Value {
  final int numerator;
  final int denominator;
  const FractionValue(this.numerator, this.denominator);

  @override
  String toDisplayString() {
    if (denominator == 1) return '$numerator';
    return '$numerator/$denominator';
  }

  @override
  double toDouble() => numerator / denominator;

  @override
  ValueType type() {
    return ValueType.fraction;
  }
}

class BooleanValue extends Value {
  final bool value;
  const BooleanValue(this.value);

  @override
  String toDisplayString() => value ? 'true' : 'false';

  @override
  double? toDouble() => null;

  @override
  ValueType type() {
    return ValueType.boolean;
  }
}

class StringValue extends Value {
  final String value;
  const StringValue(this.value);

  @override
  String toDisplayString() => value;

  @override
  double? toDouble() => double.tryParse(value);

  @override
  ValueType type() {
    return ValueType.string;
  }
}

// For future geometry, finance, etc.
class RecordValue extends Value {
  final Map<String, Value> fields;
  const RecordValue(this.fields);

  @override
  String toDisplayString() {
    return fields.entries
        .map((e) => '${e.key}: ${e.value.toDisplayString()}')
        .join(', ');
  }

  @override
  double? toDouble() => null;

  @override
  ValueType type() {
    return ValueType.record;
  }
}

class ListValue extends Value {
  final List<Value> values;
  const ListValue(this.values);

  @override
  String toDisplayString() {
    return '[${values.map((v) => v.toDisplayString()).join(', ')}]';
  }

  @override
  double? toDouble() => null;

  @override
  ValueType type() {
    return ValueType.list;
  }
}

// ============================================================================
// This architecture supports:
// - All current features (scientific calc, matrices, complex numbers)
// - Easy addition of new value types (geometry shapes, finance records)
// - Type checking in binder phase
// - Clean separation of concerns
// - Incremental feature additions
// ============================================================================
import 'package:app/core/engine.dart';
import 'package:app/core/engine_result.dart';
import 'package:app/core/eval_context.dart';

class CalculatorService {
  final EvaluationEngine engine;

  CalculatorService(this.engine);

  EngineResult evaluate(String input, EvalContext context) {
    return engine.evaluate(input, context);
  }
}
import 'package:app/models/unit_models.dart';
import 'package:app/services/unit_data.dart';
import 'package:flutter/material.dart';

class ConversionService extends ChangeNotifier {
  CategoryDefinition _currentCategory = UnitData.categories.first;
  final TextEditingController inputController = TextEditingController();
  UnitDefinition? _fromUnit;
  UnitDefinition? _toUnit;

  String _input = "";
  String _output = "";

  ConversionService() {
    _fromUnit = _currentCategory.units.first;
    _toUnit = _currentCategory.units.length > 1
        ? _currentCategory.units[1]
        : _currentCategory.units.first;
  }

  // ================= GETTERS =================
  CategoryDefinition get currentCategory => _currentCategory;
  UnitDefinition? get fromUnit => _fromUnit;
  UnitDefinition? get toUnit => _toUnit;
  String get input => _input;
  String get output => _output;

  // ================= CATEGORY =================
  void setCategory(CategoryDefinition cat) {
    _currentCategory = cat;

    _fromUnit = cat.units.first;
    _toUnit = cat.units.length > 1 ? cat.units[1] : cat.units.first;

    _input = "";
    _output = "";
    FocusManager.instance.primaryFocus?.unfocus();

    notifyListeners();
  }

  // ================= UNITS =================
  void updateUnits({UnitDefinition? from, UnitDefinition? to}) {
    if (from != null) _fromUnit = from;
    if (to != null) _toUnit = to;

    // Recalculate if input exists
    if (_input.isNotEmpty) {
      convert(_input);
      return;
    }

    notifyListeners();
  }

  // ================= CONVERSION =================
  void convert(String input) {
    _input = input;

    if (input.isEmpty || _fromUnit == null || _toUnit == null) {
      _output = "";
      notifyListeners();
      return;
    }

    try {
      final value = double.parse(input);

      // TO BASE
      final baseValue = _fromUnit!.toBase != null
          ? _fromUnit!.toBase!(value)
          : value / _fromUnit!.factor;

      // FROM BASE
      final result = _toUnit!.fromBase != null
          ? _toUnit!.fromBase!(baseValue)
          : baseValue * _toUnit!.factor;

      _output = _smartFormat(result);
    } catch (_) {
      _output = "Error";
    }

    notifyListeners();
  }

  // ================= SWAP =================
  void swap() {
    if (_fromUnit == null || _toUnit == null) return;

    final tmpUnit = _fromUnit;
    _fromUnit = _toUnit;
    _toUnit = tmpUnit;

    // Swap values (only if valid)
    if (_output.isNotEmpty) {
      _input = _output;
      _output = "";
      convert(_input);
    }

    notifyListeners();
  }

  // ================= FORMAT =================
  String _smartFormat(double value) {
    if (value == 0) return "0";
    if (value.abs() < 0.001 || value.abs() > 1e7) {
      return value.toStringAsExponential(4);
    }
    return value.toStringAsFixed(4).replaceFirst(RegExp(r'\.?0+$'), '');
  }
}
import 'package:app/core/evaluator/eval_types.dart';
import 'package:app/repositories/function_repository.dart';

import '../models/custom_function.dart';

class FunctionService {
  final FunctionRepository _repo;
  final Map<String, FunctionDef> _functions = {};
  final List<CustomFunction> _raw = [];

  FunctionService(this._repo);
  List<CustomFunction> get currentFunctions => List.unmodifiable(_raw);

  Future<void> restore() async {
    final list = await _repo.load();
    setFunctions(list);
  }

  void setFunctions(List<CustomFunction> list) {
    _raw
      ..clear()
      ..addAll(list);

    _functions
      ..clear()
      ..addEntries(
        list.map((f) => MapEntry(f.name, FunctionDef(f.parameters, f.formula))),
      );

    _repo.save(list);
  }

  Map<String, FunctionDef> get functions => _functions;
}
import 'package:logger/logger.dart';

class LoggerService {
  final _logger = Logger(
    printer: PrettyPrinter(
      methodCount: 2, // Number of method calls to be displayed
      errorMethodCount: 8, // Number of method calls if stacktrace is provided
      lineLength: 120, // Width of the output
      colors: true, // Colorful log messages
      printEmojis: true, // Print an emoji for each log message
      // Should each log print contain a timestamp
      dateTimeFormat: DateTimeFormat.onlyTimeAndSinceStart,
    ),
  );

  void info(String message) {
    _logger.log(Level.info, message);
  }

  void warn(String message) {
    _logger.log(Level.warning, message);
  }

  void debug(String message) {
    _logger.log(Level.debug, message);
  }

  void trace(String message) {
    _logger.log(Level.trace, message);
  }
}
import 'package:flutter/material.dart';
import '../models/unit_models.dart';

class UnitData {
  // Domains for grouping
  static const String dMath = "Mathematics / General";
  static const String dPhysics = "Physics / Mechanics";
  static const String dElec = "Electricity & Electronics";
  static const String dChem = "Chemistry / Science";
  static const String dBio = "Biology / Medical";
  static const String dEng = "Engineering / Tools";
  static const String dGeo = "Geography / Earth";
  static const String dComp = "Computing / Data";
  static const String dPrac = "Everyday / Practical";
  static const String dSound = "Sound / Acoustics";
  static const String dOpt = "Optics / Light";
  static const String dRad = "Radiation / Nuclear";

  static final List<CategoryDefinition> categories = [
    // --- MATHEMATICS ---
    CategoryDefinition(
      name: 'Length',
      domain: dMath,
      icon: Icons.straighten,
      units: [
        UnitDefinition(name: 'Meter', symbol: 'm', factor: 1.0),
        UnitDefinition(name: 'Kilometer', symbol: 'km', factor: 0.001),
        UnitDefinition(name: 'Centimeter', symbol: 'cm', factor: 100.0),
        UnitDefinition(name: 'Millimeter', symbol: 'mm', factor: 1000.0),
        UnitDefinition(name: 'Micrometer', symbol: 'µm', factor: 1e6),
        UnitDefinition(name: 'Nanometer', symbol: 'nm', factor: 1e9),
        UnitDefinition(name: 'Inch', symbol: 'in', factor: 39.3701),
        UnitDefinition(name: 'Foot', symbol: 'ft', factor: 3.28084),
        UnitDefinition(name: 'Yard', symbol: 'yd', factor: 1.09361),
        UnitDefinition(name: 'Mile', symbol: 'mi', factor: 0.000621371),
        UnitDefinition(
          name: 'Nautical Mile',
          symbol: 'nmi',
          factor: 0.000539957,
        ),
      ],
    ),
    CategoryDefinition(
      name: 'Area',
      domain: dMath,
      icon: Icons.layers,
      units: [
        UnitDefinition(name: 'Square Meter', symbol: 'm²', factor: 1.0),
        UnitDefinition(name: 'Sq. Kilometer', symbol: 'km²', factor: 1e-6),
        UnitDefinition(name: 'Sq. Centimeter', symbol: 'cm²', factor: 10000.0),
        UnitDefinition(name: 'Sq. Inch', symbol: 'in²', factor: 1550.0),
        UnitDefinition(name: 'Hectare', symbol: 'ha', factor: 0.0001),
        UnitDefinition(name: 'Acre', symbol: 'ac', factor: 0.000247105),
        UnitDefinition(name: 'Sq. Foot', symbol: 'ft²', factor: 10.7639),
        UnitDefinition(name: 'Sq. Mile', symbol: 'mi²', factor: 3.861e-7),
      ],
    ),

    // Update Volume to include all missing units
    CategoryDefinition(
      name: 'Volume',
      domain: dMath,
      icon: Icons.opacity,
      units: [
        UnitDefinition(name: 'Cubic Meter', symbol: 'm³', factor: 1.0),
        UnitDefinition(name: 'Liter', symbol: 'L', factor: 1000.0),
        UnitDefinition(name: 'Milliliter', symbol: 'mL', factor: 1e6),
        UnitDefinition(name: 'Cubic Centimeter', symbol: 'cc', factor: 1e6),
        UnitDefinition(name: 'Cubic Inch', symbol: 'in³', factor: 61023.7),
        UnitDefinition(name: 'Cubic Foot', symbol: 'ft³', factor: 35.3147),
        UnitDefinition(name: 'Gallon (US)', symbol: 'gal US', factor: 264.172),
        UnitDefinition(name: 'Gallon (UK)', symbol: 'gal UK', factor: 219.969),
        UnitDefinition(name: 'Quart', symbol: 'qt', factor: 1056.69),
        UnitDefinition(name: 'Pint', symbol: 'pt', factor: 2113.38),
        UnitDefinition(name: 'Cup', symbol: 'cup', factor: 4226.75),
      ],
    ),
    CategoryDefinition(
      name: 'Angle',
      domain: dMath,
      icon: Icons.architecture,
      units: [
        UnitDefinition(name: 'Degree', symbol: '°', factor: 1.0),
        UnitDefinition(name: 'Radian', symbol: 'rad', factor: 0.0174533),
        UnitDefinition(name: 'Gradian', symbol: 'gon', factor: 1.11111),
        UnitDefinition(name: 'Revolution', symbol: 'rev', factor: 1 / 360),
      ],
    ),

    // --- PHYSICS ---
    CategoryDefinition(
      name: 'Mass',
      domain: dPhysics,
      icon: Icons.scale,
      units: [
        UnitDefinition(name: 'Kilogram', symbol: 'kg', factor: 1.0),
        UnitDefinition(name: 'Gram', symbol: 'g', factor: 1000.0),
        UnitDefinition(name: 'Milligram', symbol: 'mg', factor: 1e6),
        UnitDefinition(name: 'Microgram', symbol: 'µg', factor: 1e9),
        UnitDefinition(name: 'Tonne', symbol: 't', factor: 0.001),
        UnitDefinition(name: 'Pound', symbol: 'lb', factor: 2.20462),
        UnitDefinition(name: 'Ounce', symbol: 'oz', factor: 35.274),
        UnitDefinition(name: 'Atomic Mass Unit', symbol: 'u', factor: 6.022e26),
      ],
    ),

    // Update Time to include microsecond
    CategoryDefinition(
      name: 'Time',
      domain: dPhysics,
      icon: Icons.schedule,
      units: [
        UnitDefinition(name: 'Second', symbol: 's', factor: 1.0),
        UnitDefinition(name: 'Millisecond', symbol: 'ms', factor: 1000.0),
        UnitDefinition(name: 'Microsecond', symbol: 'µs', factor: 1e6),
        UnitDefinition(name: 'Minute', symbol: 'min', factor: 1 / 60),
        UnitDefinition(name: 'Hour', symbol: 'h', factor: 1 / 3600),
        UnitDefinition(name: 'Day', symbol: 'd', factor: 1 / 86400),
        UnitDefinition(name: 'Year', symbol: 'yr', factor: 1 / 31536000),
      ],
    ),

    // NEW: Acceleration
    CategoryDefinition(
      name: 'Acceleration',
      domain: dPhysics,
      icon: Icons.speed,
      units: [
        UnitDefinition(name: 'Meters/sec²', symbol: 'm/s²', factor: 1.0),
        UnitDefinition(name: 'G-force', symbol: 'g', factor: 0.101972),
        UnitDefinition(name: 'Feet/sec²', symbol: 'ft/s²', factor: 3.28084),
      ],
    ),

    // Update Pressure to include kilopascal
    CategoryDefinition(
      name: 'Pressure',
      domain: dPhysics,
      icon: Icons.compress,
      units: [
        UnitDefinition(name: 'Pascal', symbol: 'Pa', factor: 1.0),
        UnitDefinition(name: 'Kilopascal', symbol: 'kPa', factor: 0.001),
        UnitDefinition(name: 'Bar', symbol: 'bar', factor: 1e-5),
        UnitDefinition(name: 'Atmosphere', symbol: 'atm', factor: 9.8692e-6),
        UnitDefinition(name: 'Torr', symbol: 'Torr', factor: 0.00750062),
        UnitDefinition(name: 'mmHg', symbol: 'mmHg', factor: 0.00750062),
        UnitDefinition(name: 'PSI', symbol: 'psi', factor: 0.000145038),
      ],
    ),

    // NEW: Density
    CategoryDefinition(
      name: 'Density',
      domain: dPhysics,
      icon: Icons.grain,
      units: [
        UnitDefinition(name: 'kg/m³', symbol: 'kg/m³', factor: 1.0),
        UnitDefinition(name: 'g/cm³', symbol: 'g/cm³', factor: 0.001),
        UnitDefinition(name: 'lb/ft³', symbol: 'lb/ft³', factor: 0.062428),
      ],
    ),

    // NEW: Frequency
    CategoryDefinition(
      name: 'Frequency',
      domain: dPhysics,
      icon: Icons.waves,
      units: [
        UnitDefinition(name: 'Hertz', symbol: 'Hz', factor: 1.0),
        UnitDefinition(name: 'Kilohertz', symbol: 'kHz', factor: 0.001),
        UnitDefinition(name: 'Megahertz', symbol: 'MHz', factor: 1e-6),
        UnitDefinition(name: 'Gigahertz', symbol: 'GHz', factor: 1e-9),
      ],
    ),

    // Update Power to include megawatt
    CategoryDefinition(
      name: 'Power',
      domain: dEng,
      icon: Icons.power,
      units: [
        UnitDefinition(name: 'Watt', symbol: 'W', factor: 1.0),
        UnitDefinition(name: 'Kilowatt', symbol: 'kW', factor: 0.001),
        UnitDefinition(name: 'Megawatt', symbol: 'MW', factor: 1e-6),
        UnitDefinition(name: 'Horsepower', symbol: 'hp', factor: 0.00134102),
      ],
    ),
    CategoryDefinition(
      name: 'Force',
      domain: dPhysics,
      icon: Icons.compress,
      units: [
        UnitDefinition(name: 'Newton', symbol: 'N', factor: 1.0),
        UnitDefinition(name: 'Dyne', symbol: 'dyn', factor: 1e5),
        UnitDefinition(name: 'Pound-force', symbol: 'lbf', factor: 0.224809),
        UnitDefinition(name: 'Kilogram-force', symbol: 'kgf', factor: 0.101972),
      ],
    ),
    CategoryDefinition(
      name: 'Energy',
      domain: dPhysics,
      icon: Icons.bolt,
      units: [
        UnitDefinition(name: 'Joule', symbol: 'J', factor: 1.0),
        UnitDefinition(name: 'Kilojoule', symbol: 'kJ', factor: 0.001),
        UnitDefinition(name: 'Calorie', symbol: 'cal', factor: 0.239006),
        UnitDefinition(
          name: 'Kilocalorie',
          symbol: 'kcal',
          factor: 0.000239006,
        ),
        UnitDefinition(name: 'Watt-hour', symbol: 'Wh', factor: 0.000277778),
        UnitDefinition(name: 'Kilowatt-hour', symbol: 'kWh', factor: 2.7778e-7),
        UnitDefinition(name: 'Electronvolt', symbol: 'eV', factor: 6.242e18),
      ],
    ),

    // --- ELECTRICITY ---
    CategoryDefinition(
      name: 'Voltage',
      domain: dElec,
      icon: Icons.electric_bolt,
      units: [
        UnitDefinition(name: 'Volt', symbol: 'V', factor: 1.0),
        UnitDefinition(name: 'Millivolt', symbol: 'mV', factor: 1000.0),
        UnitDefinition(name: 'Kilovolt', symbol: 'kV', factor: 0.001),
      ],
    ),
    CategoryDefinition(
      name: 'Current',
      domain: dElec,
      icon: Icons.flash_on,
      units: [
        UnitDefinition(name: 'Ampere', symbol: 'A', factor: 1.0),
        UnitDefinition(name: 'Milliampere', symbol: 'mA', factor: 1000.0),
        UnitDefinition(name: 'Microampere', symbol: 'µA', factor: 1e6),
      ],
    ),
    CategoryDefinition(
      name: 'Resistance',
      domain: dElec,
      icon: Icons.power_input,
      units: [
        UnitDefinition(name: 'Ohm', symbol: 'Ω', factor: 1.0),
        UnitDefinition(name: 'Kilo-ohm', symbol: 'kΩ', factor: 0.001),
        UnitDefinition(name: 'Mega-ohm', symbol: 'MΩ', factor: 1e-6),
      ],
    ),
    CategoryDefinition(
      name: 'Capacitance',
      domain: dElec,
      icon: Icons.battery_full,
      units: [
        UnitDefinition(name: 'Farad', symbol: 'F', factor: 1.0),
        UnitDefinition(name: 'Microfarad', symbol: 'µF', factor: 1e6),
        UnitDefinition(name: 'Nanofarad', symbol: 'nF', factor: 1e9),
        UnitDefinition(name: 'Picofarad', symbol: 'pF', factor: 1e12),
      ],
    ),
    // NEW: Inductance
    CategoryDefinition(
      name: 'Inductance',
      domain: dElec,
      icon: Icons.settings_input_component,
      units: [
        UnitDefinition(name: 'Henry', symbol: 'H', factor: 1.0),
        UnitDefinition(name: 'Millihenry', symbol: 'mH', factor: 1000.0),
        UnitDefinition(name: 'Microhenry', symbol: 'µH', factor: 1e6),
      ],
    ),

    // NEW: Electric Charge
    CategoryDefinition(
      name: 'Electric Charge',
      domain: dElec,
      icon: Icons.battery_charging_full,
      units: [
        UnitDefinition(name: 'Coulomb', symbol: 'C', factor: 1.0),
        UnitDefinition(name: 'Ampere-hour', symbol: 'Ah', factor: 1 / 3600),
        UnitDefinition(name: 'Milliampere-hour', symbol: 'mAh', factor: 3.6),
      ],
    ),

    // NEW: Electrical Power
    CategoryDefinition(
      name: 'Electrical Power',
      domain: dElec,
      icon: Icons.power_settings_new,
      units: [
        UnitDefinition(name: 'Watt', symbol: 'W', factor: 1.0),
        UnitDefinition(name: 'Volt-Ampere', symbol: 'VA', factor: 1.0),
        UnitDefinition(name: 'VAR', symbol: 'VAR', factor: 1.0),
      ],
    ),

    // --- COMPUTING ---
    CategoryDefinition(
      name: 'Data Size',
      domain: dComp,
      icon: Icons.data_usage,
      units: [
        UnitDefinition(name: 'Byte', symbol: 'B', factor: 1.0),
        UnitDefinition(name: 'Bit', symbol: 'b', factor: 8.0),
        UnitDefinition(name: 'Kilobyte', symbol: 'KB', factor: 1 / 1024),
        UnitDefinition(
          name: 'Megabyte',
          symbol: 'MB',
          factor: 1 / (1024 * 1024),
        ),
        UnitDefinition(
          name: 'Gigabyte',
          symbol: 'GB',
          factor: 1 / (1024 * 1024 * 1024),
        ),
        UnitDefinition(
          name: 'Terabyte',
          symbol: 'TB',
          factor: 1 / (1024 * 1024 * 1024 * 1024),
        ),
      ],
    ),
    CategoryDefinition(
      name: 'Data Rate',
      domain: dComp,
      icon: Icons.wifi,
      units: [
        UnitDefinition(name: 'bps', symbol: 'bps', factor: 1.0),
        UnitDefinition(name: 'kbps', symbol: 'kbps', factor: 1e-3),
        UnitDefinition(name: 'Mbps', symbol: 'Mbps', factor: 1e-6),
        UnitDefinition(name: 'Gbps', symbol: 'Gbps', factor: 1e-9),
      ],
    ),

    // --- PRACTICAL / EVERYDAY ---
    CategoryDefinition(
      name: 'Fuel Efficiency',
      domain: dPrac,
      icon: Icons.local_gas_station,
      units: [
        UnitDefinition(name: 'Kilometer / Liter', symbol: 'km/L', factor: 1.0),
        UnitDefinition(
          name: 'Miles / Gallon (US)',
          symbol: 'mpg',
          factor: 2.35215,
        ),
        // L/100km is inverse, requires a custom formula
        UnitDefinition(
          name: 'L/100km',
          symbol: 'L/100',
          toBase: (v) => 100 / v,
          fromBase: (v) => 100 / v,
        ),
      ],
    ),
    CategoryDefinition(
      name: 'Light',
      domain: dPrac,
      icon: Icons.light_mode,
      units: [
        UnitDefinition(name: 'Lumen', symbol: 'lm', factor: 1.0),
        UnitDefinition(name: 'Lux', symbol: 'lx', factor: 1.0),
        UnitDefinition(name: 'Candela', symbol: 'cd', factor: 1.0),
      ],
    ),
    CategoryDefinition(
      name: 'Temperature',
      domain: dPhysics,
      icon: Icons.thermostat,
      units: [
        UnitDefinition(
          name: 'Celsius',
          symbol: '°C',
          toBase: (v) => v + 273.15,
          fromBase: (v) => v - 273.15,
        ),
        UnitDefinition(
          name: 'Fahrenheit',
          symbol: '°F',
          toBase: (v) => (v - 32) * 5 / 9 + 273.15,
          fromBase: (v) => (v - 273.15) * 9 / 5 + 32,
        ),
        UnitDefinition(name: 'Kelvin', symbol: 'K', factor: 1.0),
      ],
    ),

    CategoryDefinition(
      name: 'Speed',
      domain: dPhysics,
      icon: Icons.speed,
      units: [
        UnitDefinition(name: 'Meters/sec', symbol: 'm/s', factor: 1.0),
        UnitDefinition(name: 'Km/hour', symbol: 'km/h', factor: 3.6),
        UnitDefinition(name: 'Miles/hour', symbol: 'mph', factor: 2.23694),
        UnitDefinition(name: 'Knots', symbol: 'kn', factor: 1.94384),
      ],
    ),

    // ================= CHEMISTRY =================
    CategoryDefinition(
      name: 'Amount of Substance',
      domain: dChem,
      icon: Icons.science,
      units: [UnitDefinition(name: 'Mole', symbol: 'mol', factor: 1.0)],
    ),

    // Update Concentration with all missing units
    CategoryDefinition(
      name: 'Concentration',
      domain: dChem,
      icon: Icons.science,
      units: [
        UnitDefinition(name: 'Molarity', symbol: 'mol/L', factor: 1.0),
        UnitDefinition(name: 'Molality', symbol: 'mol/kg', factor: 1.0),
        UnitDefinition(name: 'Normality', symbol: 'N', factor: 1.0),
        UnitDefinition(name: 'ppm', symbol: 'ppm', factor: 1e6),
        UnitDefinition(name: 'ppb', symbol: 'ppb', factor: 1e9),
        // Note: Mass/Volume percent would need special handling
      ],
    ),

    // NEW: Reaction Rate
    CategoryDefinition(
      name: 'Reaction Rate',
      domain: dChem,
      icon: Icons.timeline,
      units: [
        UnitDefinition(name: 'mol/L·s', symbol: 'mol/L·s', factor: 1.0),
        UnitDefinition(name: 's⁻¹', symbol: 's⁻¹', factor: 1.0),
      ],
    ),

    // NEW: Gas Volume (Same as regular volume but under Chemistry)
    CategoryDefinition(
      name: 'Gas Volume',
      domain: dChem,
      icon: Icons.air,
      units: [
        UnitDefinition(name: 'Liter', symbol: 'L', factor: 1.0),
        UnitDefinition(name: 'Cubic Meter', symbol: 'm³', factor: 0.001),
        UnitDefinition(name: 'Milliliter', symbol: 'mL', factor: 1000.0),
      ],
    ),

    // ================= BIOLOGY / MEDICAL =================
    // NEW: Mass (Small Scale)
    CategoryDefinition(
      name: 'Mass (Micro)',
      domain: dBio,
      icon: Icons.balance,
      units: [
        UnitDefinition(name: 'Gram', symbol: 'g', factor: 1.0),
        UnitDefinition(name: 'Milligram', symbol: 'mg', factor: 1000.0),
        UnitDefinition(name: 'Microgram', symbol: 'µg', factor: 1e6),
        UnitDefinition(name: 'Nanogram', symbol: 'ng', factor: 1e9),
      ],
    ),

    // NEW: Length (Microscopic)
    CategoryDefinition(
      name: 'Length (Micro)',
      domain: dBio,
      icon: Icons.zoom_in,
      units: [
        UnitDefinition(name: 'Micrometer', symbol: 'µm', factor: 1.0),
        UnitDefinition(name: 'Nanometer', symbol: 'nm', factor: 1000.0),
        UnitDefinition(name: 'Angstrom', symbol: 'Å', factor: 10000.0),
      ],
    ),

    // Update Medical Volume
    CategoryDefinition(
      name: 'Volume (Medical)',
      domain: dBio,
      icon: Icons.medical_services,
      units: [
        UnitDefinition(name: 'Milliliter', symbol: 'mL', factor: 1.0),
        UnitDefinition(name: 'Microliter', symbol: 'µL', factor: 1000.0),
        UnitDefinition(name: 'Drop', symbol: 'gtt', factor: 20.0), // ~0.05mL
      ],
    ),

    // NEW: Concentration (Bio)
    CategoryDefinition(
      name: 'Bio Concentration',
      domain: dBio,
      icon: Icons.colorize,
      units: [
        UnitDefinition(name: 'mg/mL', symbol: 'mg/mL', factor: 1.0),
        UnitDefinition(name: 'µg/mL', symbol: 'µg/mL', factor: 1000.0),
        // Note: IU is substance-specific, can't be converted generally
      ],
    ),

    // NEW: Blood Pressure
    CategoryDefinition(
      name: 'Blood Pressure',
      domain: dBio,
      icon: Icons.monitor_heart,
      units: [
        UnitDefinition(name: 'mmHg', symbol: 'mmHg', factor: 1.0),
        UnitDefinition(name: 'kPa', symbol: 'kPa', factor: 0.133322),
      ],
    ),
    CategoryDefinition(
      name: 'Heart Rate',
      domain: dBio,
      icon: Icons.favorite,
      units: [
        UnitDefinition(name: 'Beats per Minute', symbol: 'bpm', factor: 1.0),
      ],
    ),

    // ================= ENGINEERING =================
    CategoryDefinition(
      name: 'Torque',
      domain: dEng,
      icon: Icons.settings,
      units: [
        UnitDefinition(name: 'Newton-meter', symbol: 'N·m', factor: 1.0),
        UnitDefinition(name: 'Pound-foot', symbol: 'lb·ft', factor: 0.737562),
      ],
    ),
    // NEW: Stress / Young's Modulus
    CategoryDefinition(
      name: 'Stress',
      domain: dEng,
      icon: Icons.straighten,
      units: [
        UnitDefinition(name: 'Pascal', symbol: 'Pa', factor: 1.0),
        UnitDefinition(name: 'Megapascal', symbol: 'MPa', factor: 1e-6),
        UnitDefinition(name: 'Gigapascal', symbol: 'GPa', factor: 1e-9),
        UnitDefinition(name: 'PSI', symbol: 'psi', factor: 0.000145038),
      ],
    ),

    // NEW: Strain
    CategoryDefinition(
      name: 'Strain',
      domain: dEng,
      icon: Icons.compress,
      units: [
        UnitDefinition(name: 'Unitless', symbol: '', factor: 1.0),
        UnitDefinition(name: 'Percent', symbol: '%', factor: 100.0),
      ],
    ),

    // NEW: Flow Rate
    CategoryDefinition(
      name: 'Flow Rate',
      domain: dEng,
      icon: Icons.water_drop,
      units: [
        UnitDefinition(name: 'm³/s', symbol: 'm³/s', factor: 1.0),
        UnitDefinition(name: 'L/s', symbol: 'L/s', factor: 1000.0),
        UnitDefinition(name: 'L/min', symbol: 'L/min', factor: 60000.0),
        UnitDefinition(name: 'CFM', symbol: 'CFM', factor: 2118.88),
        UnitDefinition(name: 'Gallon/min', symbol: 'GPM', factor: 15850.3),
      ],
    ),

    // NEW: Viscosity
    CategoryDefinition(
      name: 'Viscosity',
      domain: dEng,
      icon: Icons.water,
      units: [
        UnitDefinition(name: 'Pascal-second', symbol: 'Pa·s', factor: 1.0),
        UnitDefinition(name: 'Poise', symbol: 'P', factor: 10.0),
        UnitDefinition(name: 'Centipoise', symbol: 'cP', factor: 1000.0),
      ],
    ),

    // NEW: Rotational Speed
    CategoryDefinition(
      name: 'Rotational Speed',
      domain: dEng,
      icon: Icons.rotate_right,
      units: [
        UnitDefinition(name: 'RPM', symbol: 'RPM', factor: 1.0),
        UnitDefinition(
          name: 'rad/s',
          symbol: 'rad/s',
          factor: 60 / (2 * 3.14159),
        ),
        UnitDefinition(name: 'Degrees/s', symbol: '°/s', factor: 6.0),
      ],
    ),

    // ================= GEOGRAPHY =================
    CategoryDefinition(
      name: 'Land Area',
      domain: dGeo,
      icon: Icons.map,
      units: [
        UnitDefinition(name: 'Square Kilometer', symbol: 'km²', factor: 1.0),
        UnitDefinition(name: 'Hectare', symbol: 'ha', factor: 100.0),
        UnitDefinition(name: 'Acre', symbol: 'ac', factor: 247.105),
      ],
    ),
    // NEW: Elevation / Depth
    CategoryDefinition(
      name: 'Elevation',
      domain: dGeo,
      icon: Icons.terrain,
      units: [
        UnitDefinition(name: 'Meter', symbol: 'm', factor: 1.0),
        UnitDefinition(name: 'Foot', symbol: 'ft', factor: 3.28084),
        UnitDefinition(name: 'Kilometer', symbol: 'km', factor: 0.001),
        UnitDefinition(name: 'Mile', symbol: 'mi', factor: 0.000621371),
      ],
    ),

    // NEW: Geographic Coordinates
    CategoryDefinition(
      name: 'Coordinates',
      domain: dGeo,
      icon: Icons.location_on,
      units: [
        UnitDefinition(name: 'Degree', symbol: '°', factor: 1.0),
        UnitDefinition(name: 'Minute', symbol: '′', factor: 60.0),
        UnitDefinition(name: 'Second', symbol: '″', factor: 3600.0),
      ],
    ),

    // TODO: Seismic Energy (Richter/Moment magnitude) uses logarithmic scale
    // and cannot be converted linearly - would need special handling

    // ==================== ADDITIONAL USEFUL CATEGORIES ====================

    // NEW: Sound / Acoustics Domain
    // Add to domains: static const String dSound = "Sound / Acoustics";

    // NEW: Sound Level
    CategoryDefinition(
      name: 'Sound Level',
      domain: dSound,
      icon: Icons.volume_up,
      units: [
        UnitDefinition(name: 'Decibel', symbol: 'dB', factor: 1.0),
        // Note: dB is logarithmic and context-dependent
      ],
    ),

    // NEW: Sound Frequency (could also go under Physics)
    CategoryDefinition(
      name: 'Audio Frequency',
      domain: dSound,
      icon: Icons.audiotrack,
      units: [
        UnitDefinition(name: 'Hertz', symbol: 'Hz', factor: 1.0),
        UnitDefinition(name: 'Kilohertz', symbol: 'kHz', factor: 0.001),
      ],
    ),

    // NEW: Optics / Light Domain
    // Add to domains: static const String dOpt = "Optics / Light";

    // NEW: Wavelength
    CategoryDefinition(
      name: 'Wavelength',
      domain: dOpt,
      icon: Icons.waves,
      units: [
        UnitDefinition(name: 'Nanometer', symbol: 'nm', factor: 1.0),
        UnitDefinition(name: 'Micrometer', symbol: 'µm', factor: 0.001),
        UnitDefinition(name: 'Angstrom', symbol: 'Å', factor: 10.0),
      ],
    ),

    // NEW: Illuminance (Better than just "Light")
    CategoryDefinition(
      name: 'Illuminance',
      domain: dOpt,
      icon: Icons.light_mode,
      units: [
        UnitDefinition(name: 'Lux', symbol: 'lx', factor: 1.0),
        UnitDefinition(name: 'Foot-candle', symbol: 'fc', factor: 0.092903),
      ],
    ),

    // NEW: Luminous Intensity
    CategoryDefinition(
      name: 'Luminous Intensity',
      domain: dOpt,
      icon: Icons.lightbulb,
      units: [UnitDefinition(name: 'Candela', symbol: 'cd', factor: 1.0)],
    ),

    // NEW: Luminous Flux
    CategoryDefinition(
      name: 'Luminous Flux',
      domain: dOpt,
      icon: Icons.flare,
      units: [UnitDefinition(name: 'Lumen', symbol: 'lm', factor: 1.0)],
    ),

    // NEW: Radiation Domain
    // Add to domains: static const String dRad = "Radiation / Nuclear";

    // NEW: Radioactivity
    CategoryDefinition(
      name: 'Radioactivity',
      domain: dRad,
      icon: Icons.warning,
      units: [
        UnitDefinition(name: 'Becquerel', symbol: 'Bq', factor: 1.0),
        UnitDefinition(name: 'Curie', symbol: 'Ci', factor: 2.7027e-11),
      ],
    ),

    // NEW: Absorbed Dose
    CategoryDefinition(
      name: 'Radiation Dose',
      domain: dRad,
      icon: Icons.shield,
      units: [
        UnitDefinition(name: 'Gray', symbol: 'Gy', factor: 1.0),
        UnitDefinition(name: 'Rad', symbol: 'rad', factor: 100.0),
        UnitDefinition(name: 'Sievert', symbol: 'Sv', factor: 1.0),
        UnitDefinition(name: 'Rem', symbol: 'rem', factor: 100.0),
      ],
    ),

    // NEW: Cooking / Kitchen (Practical)
    CategoryDefinition(
      name: 'Cooking Volume',
      domain: dPrac,
      icon: Icons.restaurant,
      units: [
        UnitDefinition(name: 'Cup', symbol: 'cup', factor: 1.0),
        UnitDefinition(name: 'Tablespoon', symbol: 'tbsp', factor: 16.0),
        UnitDefinition(name: 'Teaspoon', symbol: 'tsp', factor: 48.0),
        UnitDefinition(name: 'Milliliter', symbol: 'mL', factor: 236.588),
        UnitDefinition(name: 'Fluid Ounce', symbol: 'fl oz', factor: 8.0),
      ],
    ),

    // NEW: Cooking Mass
    CategoryDefinition(
      name: 'Cooking Mass',
      domain: dPrac,
      icon: Icons.kitchen,
      units: [
        UnitDefinition(name: 'Gram', symbol: 'g', factor: 1.0),
        UnitDefinition(name: 'Kilogram', symbol: 'kg', factor: 0.001),
        UnitDefinition(name: 'Ounce', symbol: 'oz', factor: 0.035274),
        UnitDefinition(name: 'Pound', symbol: 'lb', factor: 0.00220462),
      ],
    ),

    // TODO: Printing / Paper
    CategoryDefinition(
      name: 'Paper Size',
      domain: dPrac,
      icon: Icons.print,
      units: [
        // These would need special handling as they're not linear conversions
        // Could just show common sizes as reference
      ],
    ),

    // TODO: Shoe Size
    CategoryDefinition(
      name: 'Shoe Size',
      domain: dPrac,
      icon: Icons.hiking,
      units: [
        // US, UK, EU sizes - would need lookup tables
      ],
    ),
  ];
}

