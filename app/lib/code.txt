import 'package:app/core/evaluator/eval_types.dart';

class EvalContext {
  final Map<String, double> variables;
  final Map<String, FunctionDef> functions;

  const EvalContext({this.variables = const {}, this.functions = const {}});
}
enum AngleMode { rad, deg }

sealed class EvaluationResult {
  const EvaluationResult();
}

class EvalError extends EvaluationResult {
  final EvalErrorType type;
  final String message;
  const EvalError(this.type, this.message);
}

enum EvalErrorType { syntax, divisionByZero, domain, unknown }

class EvalSuccess extends EvaluationResult {
  final double value;
  const EvalSuccess(this.value);
}

class RecursionGuard {
  final int depth;
  final int maxDepth;

  const RecursionGuard(this.depth, this.maxDepth);

  RecursionGuard next() {
    if (depth >= maxDepth) {
      throw const EvalError(
        EvalErrorType.domain,
        'Maximum recursion depth exceeded',
      );
    }
    return RecursionGuard(depth + 1, maxDepth);
  }
}

class FunctionDef {
  final List<String> params;
  final String body;

  const FunctionDef(this.params, this.body);
}
import 'dart:math' as math;

import 'package:app/core/evaluator/eval_context.dart';
import 'package:app/core/evaluator/eval_types.dart';

class ExpressionEvaluator {
  final Map<String, double> _cache = {};

  EvaluationResult evaluate(
    String expr,
    AngleMode mode, {
    EvalContext context = const EvalContext(),
    RecursionGuard guard = const RecursionGuard(0, 32),
  }) {
    try {
      final funcSig = context.functions.entries
          .map((e) => '${e.key}(${e.value.params.join(",")}):${e.value.body}')
          .join('|');

      final key = '$expr|$mode|${context.variables}|$funcSig';

      if (_cache.containsKey(key)) {
        return EvalSuccess(_cache[key]!);
      }

      final tokens = _insertImplicitMultiplication(_tokenize(expr));
      final postfix = _toPostfix(tokens);
      final result = _evalPostfix(postfix, mode, context, guard);
      _cache[key] = result;
      return EvalSuccess(result);
    } on EvalError catch (e) {
      return e;
    } catch (e) {
      return const EvalError(EvalErrorType.unknown, 'Unknown error');
    }
  }

  /* ===================== TOKENIZER ===================== */

  List<String> _tokenize(String expr) {
    expr = expr
        .replaceAll('π', math.pi.toString())
        .replaceAllMapped(
          RegExp(r'(?<![\w.])e(?![\w.])'),
          (_) => math.e.toString(),
        );

    final tokens = <String>[];
    final buf = StringBuffer();

    void flush() {
      if (buf.isNotEmpty) {
        tokens.add(buf.toString());
        buf.clear();
      }
    }

    for (int i = 0; i < expr.length; i++) {
      final c = expr[i];

      if ('0123456789.'.contains(c)) {
        buf.write(c);
      } else {
        flush();
        if (c.trim().isEmpty) continue;

        if (c == ',') {
          tokens.add(',');
          continue;
        }

        if ('+-*/^()'.contains(c)) {
          if ((c == '-' || c == '+') &&
              (tokens.isEmpty || '()+-*/^'.contains(tokens.last))) {
            tokens.add(c == '-' ? 'u-' : 'u+');
          } else {
            tokens.add(c);
          }
        } else {
          buf.write(c);
          while (i + 1 < expr.length &&
              RegExp(r'[a-z]').hasMatch(expr[i + 1])) {
            buf.write(expr[++i]);
          }
          tokens.add(buf.toString());
          buf.clear();
        }
      }
    }
    flush();
    return tokens;
  }

  /* ===================== IMPLICIT MULTIPLICATION ===================== */
  List<String> _insertImplicitMultiplication(List<String> t) {
    final out = <String>[];

    bool isValue(String x) => _isNumber(x) || x == ')';
    bool isStart(String x) => _isNumber(x) || x == '(' || _isFunction(x);

    for (int i = 0; i < t.length; i++) {
      out.add(t[i]);
      if (i == t.length - 1) break;

      final a = t[i];
      final b = t[i + 1];

      if (isValue(a) && isStart(b)) {
        out.add('*');
      }
    }
    return out;
  }

  /* ===================== SHUNTING YARD ===================== */

  List<String> _toPostfix(List<String> tokens) {
    final out = <String>[];
    final stack = <String>[];

    final prec = {'u+': 5, 'u-': 5, '^': 4, '*': 3, '/': 3, '+': 2, '-': 2};

    final rightAssoc = {'^', 'u-', 'u+'};

    for (final tok in tokens) {
      if (_isNumber(tok)) {
        out.add(tok);
      } else if (_isFunction(tok)) {
        stack.add(tok);
      } else if (tok == '(') {
        stack.add(tok);
      } else if (tok == ')') {
        while (stack.isNotEmpty && stack.last != '(') {
          out.add(stack.removeLast());
        }
        if (stack.isEmpty) {
          throw const EvalError(EvalErrorType.syntax, 'Mismatched parentheses');
        }
        stack.removeLast();
        if (stack.isNotEmpty && _isFunction(stack.last)) {
          out.add(stack.removeLast());
        }
      } else if (tok == ',') {
        while (stack.isNotEmpty && stack.last != '(') {
          out.add(stack.removeLast());
        }
      } else {
        while (stack.isNotEmpty &&
            prec.containsKey(stack.last) &&
            (rightAssoc.contains(tok)
                ? prec[stack.last]! > prec[tok]!
                : prec[stack.last]! >= prec[tok]!)) {
          out.add(stack.removeLast());
        }
        stack.add(tok);
      }
    }

    while (stack.isNotEmpty) {
      if (stack.last == '(') {
        throw const EvalError(EvalErrorType.syntax, 'Mismatched parentheses');
      }
      out.add(stack.removeLast());
    }
    return out;
  }

  /* ===================== POSTFIX ===================== */

  double _evalPostfix(
    List<String> t,
    AngleMode mode,
    EvalContext context,
    RecursionGuard guard,
  ) {
    final stack = <double>[];
    final angle = mode == AngleMode.rad ? 1.0 : math.pi / 180;

    for (final tok in t) {
      if (_isNumber(tok)) {
        stack.add(double.parse(tok));
      } else if (tok == 'u-') {
        if (stack.isEmpty) {
          throw const EvalError(EvalErrorType.syntax, 'Unary minus error');
        }
        stack.add(-stack.removeLast());
      } else if (tok == 'u+') {
        if (stack.isEmpty) {
          throw const EvalError(EvalErrorType.syntax, 'Unary plus error');
        }
      } else if (context.functions.containsKey(tok)) {
        final def = context.functions[tok]!;

        if (stack.length < def.params.length) {
          throw EvalError(
            EvalErrorType.syntax,
            'Function $tok expects ${def.params.length} arguments',
          );
        }

        // Pop arguments (reverse order)
        final args = <double>[];
        for (int i = 0; i < def.params.length; i++) {
          args.insert(0, stack.removeLast());
        }

        // New variable scope
        final newVars = Map<String, double>.from(context.variables);
        for (int i = 0; i < def.params.length; i++) {
          newVars[def.params[i]] = args[i];
        }

        final result = evaluate(
          def.body,
          mode,
          context: EvalContext(
            variables: newVars,
            functions: context.functions,
          ),
          guard: guard.next(),
        );

        if (result is EvalSuccess) {
          stack.add(result.value);
        } else {
          throw result as EvalError;
        }
      } else if (_isFunction(tok)) {
        if (stack.isEmpty) {
          throw const EvalError(
            EvalErrorType.syntax,
            'Missing function argument',
          );
        }
        final v = stack.removeLast();
        switch (tok) {
          case 'sin':
            stack.add(math.sin(v * angle));
            break;
          case 'cos':
            stack.add(math.cos(v * angle));
            break;
          case 'tan':
            stack.add(math.tan(v * angle));
            break;
          case 'ln':
            if (v <= 0) {
              throw const EvalError(EvalErrorType.domain, 'ln(x) x<=0');
            }
            stack.add(math.log(v));
            break;
          case 'log':
            if (v <= 0) {
              throw const EvalError(EvalErrorType.domain, 'log(x) x<=0');
            }
            stack.add(math.log(v) / math.ln10);
            break;
          case 'sqrt':
            if (v < 0) {
              throw const EvalError(EvalErrorType.domain, 'sqrt(x) x<0');
            }
            stack.add(math.sqrt(v));
            break;
          case 'abs':
            stack.add(v.abs());
            break;

          case 'fact':
            if (v < 0 || v != v.floor()) {
              throw const EvalError(
                EvalErrorType.domain,
                'factorial domain error',
              );
            }
            if (v > 20) {
              throw const EvalError(
                EvalErrorType.domain,
                'factorial too large',
              );
            }
            int res = 1;
            for (int i = 1; i <= v; i++) {
              res *= i;
            }
            stack.add(res.toDouble());
            break;
        }
      } else if (_isIdentifier(tok)) {
        if (!context.variables.containsKey(tok)) {
          throw EvalError(EvalErrorType.syntax, 'Unknown variable: $tok');
        }
        stack.add(context.variables[tok]!);
      } else if (tok == 'mod') {
        if (stack.length < 2) {
          throw const EvalError(EvalErrorType.syntax, 'mod(a,b) needs 2 args');
        }
        final b = stack.removeLast();
        final a = stack.removeLast();
        if (b == 0) {
          throw const EvalError(EvalErrorType.divisionByZero, 'mod by zero');
        }
        stack.add(a - b * (a / b).floor());
      } else {
        if (stack.length < 2) {
          throw const EvalError(EvalErrorType.syntax, 'Binary operator error');
        }
        final b = stack.removeLast();
        final a = stack.removeLast();
        switch (tok) {
          case '+':
            stack.add(a + b);
            break;
          case '-':
            stack.add(a - b);
            break;
          case '*':
            stack.add(a * b);
            break;
          case '/':
            if (b == 0) {
              throw const EvalError(
                EvalErrorType.divisionByZero,
                'Division by zero',
              );
            }
            stack.add(a / b);
            break;
          case '^':
            stack.add(math.pow(a, b).toDouble());
            break;
        }
      }
    }

    if (stack.length != 1) {
      throw const EvalError(EvalErrorType.syntax, 'Invalid expression');
    }
    return stack.single;
  }

  bool _isNumber(String s) => double.tryParse(s) != null;
  bool _isFunction(String s) => const {
    'sin',
    'cos',
    'tan',
    'ln',
    'log',
    'sqrt',
    'abs',
    'mod',
    'fact',
  }.contains(s);
  bool _isIdentifier(String s) =>
      RegExp(r'^[a-zA-Z_][a-zA-Z0-9_]*$').hasMatch(s) && !_isFunction(s);
}
import 'package:app/core/evaluator/expression_evaluator.dart';
import 'package:app/repositories/function_repository.dart';
import 'package:app/repositories/memory_repository.dart';
import 'package:app/services/calculator_service.dart';
import 'package:app/services/function_service.dart';
import 'package:flutter/material.dart';
import 'pages/calculator_home.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  final evaluator = ExpressionEvaluator();
  final memoryRepo = MemoryRepository();
  final functionRepo = FunctionRepository();

  final calculatorService = CalculatorService(evaluator, memoryRepo);
  final functionService = FunctionService(functionRepo);

  await calculatorService.restore();
  await functionService.restore();

  runApp(
    CalculatorApp(
      calculatorService: calculatorService,
      functionService: functionService,
    ),
  );
}

class CalculatorApp extends StatelessWidget {
  final CalculatorService calculatorService;
  final FunctionService functionService;

  const CalculatorApp({
    Key? key,
    required this.calculatorService,
    required this.functionService,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Scientific Calculator',
      theme: ThemeData.dark().copyWith(
        primaryColor: const Color(0xFF1E1E1E),
        scaffoldBackgroundColor: const Color(0xFF121212),
        colorScheme: const ColorScheme.dark(
          primary: Color(0xFF4CAF50),
          secondary: Color(0xFF03DAC6),
        ),
      ),
      home: CalculatorHome(
        calculatorService: calculatorService,
        functionService: functionService,
      ),
    );
  }
}
class CustomFunction {
  final String name;
  final List<String> parameters;
  final String formula;

  CustomFunction({
    required this.name,
    required this.parameters,
    required this.formula,
  });

  Map<String, dynamic> toJson() {
    return {'name': name, 'parameters': parameters, 'formula': formula};
  }

  factory CustomFunction.fromJson(Map<String, dynamic> json) {
    return CustomFunction(
      name: json['name'],
      parameters: List<String>.from(json['parameters']),
      formula: json['formula'],
    );
  }
}
import 'package:flutter/material.dart';

class BaseNCalculatorPage extends StatefulWidget {
  const BaseNCalculatorPage({Key? key}) : super(key: key);

  @override
  State<BaseNCalculatorPage> createState() => _BaseNCalculatorPageState();
}

class _BaseNCalculatorPageState extends State<BaseNCalculatorPage> {
  final TextEditingController _inputController = TextEditingController();
  int _fromBase = 10;
  int _toBase = 2;
  String _result = '';

  void _convert() {
    try {
      final input = _inputController.text.toUpperCase();
      final decimal = int.parse(input, radix: _fromBase);
      final converted = decimal.toRadixString(_toBase).toUpperCase();

      setState(() {
        _result = converted;
      });
    } catch (e) {
      setState(() {
        _result = 'Error: Invalid input';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          TextField(
            controller: _inputController,
            decoration: const InputDecoration(
              labelText: 'Input Number',
              border: OutlineInputBorder(),
            ),
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              const Text('From base: '),
              DropdownButton<int>(
                value: _fromBase,
                items: [2, 8, 10, 16]
                    .map((b) => DropdownMenuItem(value: b, child: Text('$b')))
                    .toList(),
                onChanged: (v) => setState(() => _fromBase = v!),
              ),
              const SizedBox(width: 20),
              const Text('To base: '),
              DropdownButton<int>(
                value: _toBase,
                items: [2, 8, 10, 16]
                    .map((b) => DropdownMenuItem(value: b, child: Text('$b')))
                    .toList(),
                onChanged: (v) => setState(() => _toBase = v!),
              ),
            ],
          ),
          const SizedBox(height: 16),
          ElevatedButton(onPressed: _convert, child: const Text('Convert')),
          const SizedBox(height: 20),
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Text(
                'Result: $_result',
                style: const TextStyle(fontSize: 24),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:app/services/calculator_service.dart';
import 'package:app/services/function_service.dart';
import 'package:flutter/material.dart';
import 'scientific_calculator_page.dart';
import 'modulo_calculator_page.dart';
import 'matrix_calculator_page.dart';
import 'base_n_calculator_page.dart';
import 'conversion_page.dart';
import 'custom_functions_page.dart';

import 'package:provider/provider.dart';

import '../state/calculator_state.dart';

class CalculatorHome extends StatefulWidget {
  final CalculatorService calculatorService;
  final FunctionService functionService;

  const CalculatorHome({
    super.key,
    required this.calculatorService,
    required this.functionService,
  });

  @override
  State<CalculatorHome> createState() => _CalculatorHomeState();
}

class _CalculatorHomeState extends State<CalculatorHome> {
  int _selectedIndex = 0;

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        Provider<FunctionService>.value(value: widget.functionService),
        Provider<CalculatorService>.value(value: widget.calculatorService),
        ChangeNotifierProvider(
          create: (_) =>
              CalculatorState(widget.calculatorService, widget.functionService),
        ),
      ],
      child: Scaffold(
        body: _pages[_selectedIndex],
        bottomNavigationBar: BottomNavigationBar(
          currentIndex: _selectedIndex,
          onTap: (i) => setState(() => _selectedIndex = i),
          selectedItemColor: Colors.white, // Color for the active item
          unselectedItemColor: Colors.white60, // Color for inactive items
          type:
              BottomNavigationBarType.fixed, // Keeps labels visible and stable
          items: const [
            BottomNavigationBarItem(
              icon: Icon(Icons.calculate),
              label: 'Calculator',
            ),
            BottomNavigationBarItem(icon: Icon(Icons.percent), label: 'Modulo'),
            BottomNavigationBarItem(icon: Icon(Icons.grid_on), label: 'Matrix'),
            BottomNavigationBarItem(icon: Icon(Icons.tag), label: 'Base N'),
            BottomNavigationBarItem(
              icon: Icon(Icons.swap_horiz),
              label: 'Convert',
            ),

            BottomNavigationBarItem(
              icon: Icon(Icons.functions),
              label: 'Functions',
            ),
          ],
        ),
      ),
    );
  }

  List<Widget> get _pages => const [
    ScientificCalculatorPage(),
    ModuloCalculatorPage(),
    MatrixCalculatorPage(),
    BaseNCalculatorPage(),
    ConversionPage(),
    CustomFunctionsPage(),
  ];
}
import 'package:flutter/material.dart';
import '../utils/unit_conversions.dart';

class ConversionPage extends StatefulWidget {
  const ConversionPage({Key? key}) : super(key: key);

  @override
  State<ConversionPage> createState() => _ConversionPageState();
}

class _ConversionPageState extends State<ConversionPage> {
  final TextEditingController _inputController = TextEditingController();
  String _category = 'Length';
  String _fromUnit = 'meter';
  String _toUnit = 'kilometer';
  String _result = '';

  void _convert() {
    try {
      final input = double.parse(_inputController.text);
      final result = UnitConversions.convert(
        input,
        _category,
        _fromUnit,
        _toUnit,
      );

      setState(() {
        _result = result.toStringAsFixed(6);
      });
    } catch (e) {
      setState(() {
        _result = 'Error';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final units = UnitConversions.getUnitsForCategory(_category);

    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          DropdownButton<String>(
            value: _category,
            isExpanded: true,
            items: UnitConversions.categories
                .map((c) => DropdownMenuItem(value: c, child: Text(c)))
                .toList(),
            onChanged: (v) {
              setState(() {
                _category = v!;
                final units = UnitConversions.getUnitsForCategory(_category);
                _fromUnit = units[0];
                _toUnit = units[1];
              });
            },
          ),
          const SizedBox(height: 16),
          TextField(
            controller: _inputController,
            decoration: const InputDecoration(
              labelText: 'Value',
              border: OutlineInputBorder(),
            ),
            keyboardType: TextInputType.number,
          ),
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: DropdownButton<String>(
                  value: _fromUnit,
                  isExpanded: true,
                  items: units
                      .map((u) => DropdownMenuItem(value: u, child: Text(u)))
                      .toList(),
                  onChanged: (v) => setState(() => _fromUnit = v!),
                ),
              ),
              const Padding(
                padding: EdgeInsets.symmetric(horizontal: 8),
                child: Icon(Icons.arrow_forward),
              ),
              Expanded(
                child: DropdownButton<String>(
                  value: _toUnit,
                  isExpanded: true,
                  items: units
                      .map((u) => DropdownMenuItem(value: u, child: Text(u)))
                      .toList(),
                  onChanged: (v) => setState(() => _toUnit = v!),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          ElevatedButton(onPressed: _convert, child: const Text('Convert')),
          const SizedBox(height: 20),
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Text(
                'Result: $_result',
                style: const TextStyle(fontSize: 24),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../models/custom_function.dart';
import '../services/function_service.dart';
import '../widgets/function_test_dialog.dart';

class CustomFunctionsPage extends StatefulWidget {
  const CustomFunctionsPage({Key? key}) : super(key: key);

  @override
  State<CustomFunctionsPage> createState() => _CustomFunctionsPageState();
}

class _CustomFunctionsPageState extends State<CustomFunctionsPage> {
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _formulaController = TextEditingController();
  final TextEditingController _paramController = TextEditingController();
  final List<String> _parameters = [];

  void _addParameter() {
    if (_paramController.text.isNotEmpty) {
      setState(() {
        _parameters.add(_paramController.text);
        _paramController.clear();
      });
    }
  }

  void _saveFunction() {
    if (_nameController.text.isEmpty ||
        _formulaController.text.isEmpty ||
        _parameters.isEmpty) {
      return;
    }

    final functionService = context.read<FunctionService>();

    final newFunc = CustomFunction(
      name: _nameController.text,
      parameters: List.from(_parameters),
      formula: _formulaController.text,
    );

    final updated = [...functionService.currentFunctions, newFunc];

    functionService.setFunctions(updated);

    setState(() {
      _nameController.clear();
      _formulaController.clear();
      _parameters.clear();
    });

    ScaffoldMessenger.of(
      context,
    ).showSnackBar(const SnackBar(content: Text('Function saved!')));
  }

  void _deleteFunction(int index) {
    final functionService = context.read<FunctionService>();
    final updated = List<CustomFunction>.from(functionService.currentFunctions)
      ..removeAt(index);

    functionService.setFunctions(updated);
    setState(() {});
  }

  void _testFunction(CustomFunction func) {
    showDialog(
      context: context,
      builder: (_) => FunctionTestDialog(function: func),
    );
  }

  @override
  Widget build(BuildContext context) {
    final functionService = context.watch<FunctionService>();
    final functions = functionService.currentFunctions;

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          const Text(
            'Create Custom Function',
            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 16),

          TextField(
            controller: _nameController,
            decoration: const InputDecoration(
              labelText: 'Function Name',
              border: OutlineInputBorder(),
            ),
          ),

          const SizedBox(height: 12),
          Row(
            children: [
              Expanded(
                child: TextField(
                  controller: _paramController,
                  decoration: const InputDecoration(
                    labelText: 'Parameter',
                    border: OutlineInputBorder(),
                  ),
                ),
              ),
              const SizedBox(width: 8),
              ElevatedButton(
                onPressed: _addParameter,
                child: const Text('Add'),
              ),
            ],
          ),

          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            children: _parameters
                .map(
                  (p) => Chip(
                    label: Text(p),
                    onDeleted: () {
                      setState(() => _parameters.remove(p));
                    },
                  ),
                )
                .toList(),
          ),

          const SizedBox(height: 12),
          TextField(
            controller: _formulaController,
            maxLines: 3,
            decoration: const InputDecoration(
              labelText: 'Formula',
              border: OutlineInputBorder(),
            ),
          ),

          const SizedBox(height: 12),
          ElevatedButton(
            onPressed: _saveFunction,
            child: const Text('Save Function'),
          ),

          const SizedBox(height: 24),
          const Divider(),
          const SizedBox(height: 16),

          const Text(
            'Saved Functions',
            style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 12),

          if (functions.isEmpty)
            const Text('No custom functions yet', textAlign: TextAlign.center)
          else
            ...functions.asMap().entries.map((entry) {
              final i = entry.key;
              final f = entry.value;
              return Card(
                child: ListTile(
                  title: Text('${f.name}(${f.parameters.join(', ')})'),
                  subtitle: Text(f.formula),
                  trailing: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      IconButton(
                        icon: const Icon(Icons.play_arrow),
                        onPressed: () => _testFunction(f),
                      ),
                      IconButton(
                        icon: const Icon(Icons.delete),
                        onPressed: () => _deleteFunction(i),
                      ),
                    ],
                  ),
                ),
              );
            }),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import '../widgets/matrix_input.dart';
import '../utils/matrix_operations.dart';

class MatrixCalculatorPage extends StatefulWidget {
  const MatrixCalculatorPage({Key? key}) : super(key: key);

  @override
  State<MatrixCalculatorPage> createState() => _MatrixCalculatorPageState();
}

class _MatrixCalculatorPageState extends State<MatrixCalculatorPage> {
  int rows1 = 2, cols1 = 2;
  int rows2 = 2, cols2 = 2;
  List<List<double>> matrix1 = [
    [0, 0],
    [0, 0],
  ];
  List<List<double>> matrix2 = [
    [0, 0],
    [0, 0],
  ];
  String result = '';

  void _resizeMatrix1() {
    setState(() {
      matrix1 = List.generate(rows1, (i) => List.filled(cols1, 0.0));
    });
  }

  void _resizeMatrix2() {
    setState(() {
      matrix2 = List.generate(rows2, (i) => List.filled(cols2, 0.0));
    });
  }

  void _calculate(String operation) {
    try {
      switch (operation) {
        case 'add':
          final resultMatrix = MatrixOperations.add(matrix1, matrix2);
          setState(() {
            result = MatrixOperations.formatMatrix(resultMatrix);
          });
          break;
        case 'multiply':
          final resultMatrix = MatrixOperations.multiply(matrix1, matrix2);
          setState(() {
            result = MatrixOperations.formatMatrix(resultMatrix);
          });
          break;
        case 'det':
          final det = MatrixOperations.determinant(matrix1);
          setState(() {
            result = 'Determinant: ${det.toStringAsFixed(4)}';
          });
          break;
        case 'transpose':
          final resultMatrix = MatrixOperations.transpose(matrix1);
          setState(() {
            result = MatrixOperations.formatMatrix(resultMatrix);
          });
          break;
      }
    } catch (e) {
      setState(() {
        result = 'Error: ${e.toString()}';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          Row(
            children: [
              const Text('Matrix 1 size: '),
              DropdownButton<int>(
                value: rows1,
                items: [2, 3, 4]
                    .map((i) => DropdownMenuItem(value: i, child: Text('$i')))
                    .toList(),
                onChanged: (v) {
                  setState(() {
                    rows1 = v!;
                    _resizeMatrix1();
                  });
                },
              ),
              const Text(' × '),
              DropdownButton<int>(
                value: cols1,
                items: [2, 3, 4]
                    .map((i) => DropdownMenuItem(value: i, child: Text('$i')))
                    .toList(),
                onChanged: (v) {
                  setState(() {
                    cols1 = v!;
                    _resizeMatrix1();
                  });
                },
              ),
            ],
          ),
          MatrixInput(
            matrix: matrix1,
            rows: rows1,
            cols: cols1,
            onChanged: (i, j, value) {
              setState(() {
                matrix1[i][j] = value;
              });
            },
          ),
          const SizedBox(height: 20),
          Row(
            children: [
              const Text('Matrix 2 size: '),
              DropdownButton<int>(
                value: rows2,
                items: [2, 3, 4]
                    .map((i) => DropdownMenuItem(value: i, child: Text('$i')))
                    .toList(),
                onChanged: (v) {
                  setState(() {
                    rows2 = v!;
                    _resizeMatrix2();
                  });
                },
              ),
              const Text(' × '),
              DropdownButton<int>(
                value: cols2,
                items: [2, 3, 4]
                    .map((i) => DropdownMenuItem(value: i, child: Text('$i')))
                    .toList(),
                onChanged: (v) {
                  setState(() {
                    cols2 = v!;
                    _resizeMatrix2();
                  });
                },
              ),
            ],
          ),
          MatrixInput(
            matrix: matrix2,
            rows: rows2,
            cols: cols2,
            onChanged: (i, j, value) {
              setState(() {
                matrix2[i][j] = value;
              });
            },
          ),
          const SizedBox(height: 20),
          Wrap(
            spacing: 8,
            children: [
              ElevatedButton(
                onPressed: () => _calculate('add'),
                child: const Text('Add'),
              ),
              ElevatedButton(
                onPressed: () => _calculate('multiply'),
                child: const Text('Multiply'),
              ),
              ElevatedButton(
                onPressed: () => _calculate('det'),
                child: const Text('Det(M1)'),
              ),
              ElevatedButton(
                onPressed: () => _calculate('transpose'),
                child: const Text('Transpose M1'),
              ),
            ],
          ),
          const SizedBox(height: 20),
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Text(result.isEmpty ? 'Result will appear here' : result),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import '../utils/modulo_operations.dart';

class ModuloCalculatorPage extends StatefulWidget {
  const ModuloCalculatorPage({Key? key}) : super(key: key);

  @override
  State<ModuloCalculatorPage> createState() => _ModuloCalculatorPageState();
}

class _ModuloCalculatorPageState extends State<ModuloCalculatorPage> {
  final TextEditingController _aController = TextEditingController();
  final TextEditingController _bController = TextEditingController();
  final TextEditingController _modController = TextEditingController();
  String _result = '';

  void _calculate(String operation) {
    try {
      final a = int.parse(_aController.text);
      final b = int.parse(_bController.text);
      final mod = int.parse(_modController.text);

      int result;
      switch (operation) {
        case 'add':
          result = ModuloOperations.add(a, b, mod);
          break;
        case 'sub':
          result = ModuloOperations.subtract(a, b, mod);
          break;
        case 'mul':
          result = ModuloOperations.multiply(a, b, mod);
          break;
        case 'pow':
          result = ModuloOperations.power(a, b, mod);
          break;
        case 'inv':
          result = ModuloOperations.inverse(a, mod);
          break;
        default:
          result = 0;
      }

      setState(() {
        _result = result.toString();
      });
    } catch (e) {
      setState(() {
        _result = 'Error: ${e.toString()}';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          TextField(
            controller: _aController,
            decoration: const InputDecoration(labelText: 'Number A'),
            keyboardType: TextInputType.number,
          ),
          TextField(
            controller: _bController,
            decoration: const InputDecoration(labelText: 'Number B'),
            keyboardType: TextInputType.number,
          ),
          TextField(
            controller: _modController,
            decoration: const InputDecoration(labelText: 'Modulo'),
            keyboardType: TextInputType.number,
          ),
          const SizedBox(height: 20),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: [
              ElevatedButton(
                onPressed: () => _calculate('add'),
                child: const Text('(A + B) mod M'),
              ),
              ElevatedButton(
                onPressed: () => _calculate('sub'),
                child: const Text('(A - B) mod M'),
              ),
              ElevatedButton(
                onPressed: () => _calculate('mul'),
                child: const Text('(A × B) mod M'),
              ),
              ElevatedButton(
                onPressed: () => _calculate('pow'),
                child: const Text('A^B mod M'),
              ),
              ElevatedButton(
                onPressed: () => _calculate('inv'),
                child: const Text('A^(-1) mod M'),
              ),
            ],
          ),
          const SizedBox(height: 20),
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Text(
                'Result: $_result',
                style: const TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:app/core/evaluator/eval_types.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../state/calculator_state.dart';
import '../widgets/calculator_button.dart';

class ScientificCalculatorPage extends StatelessWidget {
  const ScientificCalculatorPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final state = context.watch<CalculatorState>();

    return Column(
      children: [
        // DISPLAY
        Container(
          padding: const EdgeInsets.all(20),
          alignment: Alignment.centerRight,
          color: const Color(0xFF1E1E1E),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              GestureDetector(
                onTapDown: (details) {
                  final box = context.findRenderObject() as RenderBox;
                  final dx = details.localPosition.dx;

                  final charWidth = 14.0; // approximate
                  final index = (dx / charWidth).floor();

                  state.setCursor(index);
                },
                child: RichText(
                  text: TextSpan(
                    children: [
                      for (int i = 0; i <= state.expression.length; i++)
                        TextSpan(
                          text: i == state.cursor
                              ? '|'
                              : (i < state.expression.length
                                    ? state.expression[i]
                                    : ''),
                          style: TextStyle(
                            fontSize: 24,
                            color: i == state.cursor
                                ? Colors.green
                                : Colors.white,
                          ),
                        ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 10),
              Text(
                state.display,
                style: const TextStyle(
                  fontSize: 48,
                  fontWeight: FontWeight.bold,
                ),
              ),
              Text(
                state.angleMode == AngleMode.rad ? 'RAD' : 'DEG',
                style: const TextStyle(fontSize: 14, color: Colors.green),
              ),
            ],
          ),
        ),

        // BUTTONS
        Expanded(
          child: GridView.count(
            crossAxisCount: 5,
            padding: const EdgeInsets.all(4),
            mainAxisSpacing: 4,
            crossAxisSpacing: 4,
            children: _buttons(context),
          ),
        ),
      ],
    );
  }

  List<Widget> _buttons(BuildContext context) {
    void press(String v) => context.read<CalculatorState>().input(v);

    Widget btn(String t, Color c) =>
        CalculatorButton(text: t, color: c, onPressed: press);

    return [
      btn('sin(', Colors.blue.shade700),
      btn('cos(', Colors.blue.shade700),
      btn('tan(', Colors.blue.shade700),
      btn('ln(', Colors.blue.shade700),
      btn('log(', Colors.blue.shade700),

      btn('sqrt(', Colors.blue.shade700),
      btn('^', Colors.blue.shade700),
      btn('π', Colors.blue.shade700),
      btn('e', Colors.blue.shade700),
      btn('RAD/DEG', Colors.green.shade700),

      btn('7', Colors.grey.shade800),
      btn('8', Colors.grey.shade800),
      btn('9', Colors.grey.shade800),
      btn('C', Colors.red.shade700),
      btn('DEL', Colors.red.shade700),

      btn('4', Colors.grey.shade800),
      btn('5', Colors.grey.shade800),
      btn('6', Colors.grey.shade800),
      btn('*', Colors.orange.shade700),
      btn('/', Colors.orange.shade700),

      btn('1', Colors.grey.shade800),
      btn('2', Colors.grey.shade800),
      btn('3', Colors.grey.shade800),
      btn('+', Colors.orange.shade700),
      btn('-', Colors.orange.shade700),

      btn('0', Colors.grey.shade800),
      btn('.', Colors.grey.shade800),
      btn('=', Colors.green.shade700),
      btn('(', Colors.grey.shade700),
      btn(')', Colors.grey.shade700),

      btn('ANS', Colors.grey.shade700),
      btn('MC', Colors.grey.shade700),
      btn('MR', Colors.grey.shade700),
      btn('M+', Colors.grey.shade700),
      btn('M-', Colors.grey.shade700),
    ];
  }
}
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/custom_function.dart';

class FunctionRepository {
  static const _key = 'custom_functions';

  Future<void> save(List<CustomFunction> functions) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonList = functions
        .map((f) => {'name': f.name, 'params': f.parameters, 'body': f.formula})
        .toList();

    await prefs.setString(_key, jsonEncode(jsonList));
  }

  Future<List<CustomFunction>> load() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_key);
    if (raw == null) return [];

    final List data = jsonDecode(raw);
    return data
        .map(
          (e) => CustomFunction(
            name: e['name'],
            parameters: List<String>.from(e['params']),
            formula: e['body'],
          ),
        )
        .toList();
  }

  Future<void> clear() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_key);
  }
}
import 'package:shared_preferences/shared_preferences.dart';

class MemoryRepository {
  static const _memKey = 'memory_value';
  static const _ansKey = 'ans_value';

  Future<void> saveMemory(double value) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setDouble(_memKey, value);
  }

  Future<double> loadMemory() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getDouble(_memKey) ?? 0.0;
  }

  Future<void> saveANS(double value) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setDouble(_ansKey, value);
  }

  Future<double?> loadANS() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getDouble(_ansKey);
  }
}
import 'package:app/core/evaluator/eval_context.dart';
import 'package:app/core/evaluator/eval_types.dart';
import 'package:app/repositories/memory_repository.dart';

import '../core/evaluator/expression_evaluator.dart';

class CalculatorService {
  final ExpressionEvaluator _evaluator;
  final MemoryRepository _memoryRepo;

  double? _ans;
  double _memory = 0.0;

  double? get ans => _ans;
  double get memory => _memory;

  CalculatorService(this._evaluator, this._memoryRepo);

  Future<void> restore() async {
    _memory = await _memoryRepo.loadMemory();
    _ans = await _memoryRepo.loadANS();
  }

  EvaluationResult evaluate(
    String expression,
    AngleMode mode,
    EvalContext context,
  ) {
    final result = _evaluator.evaluate(expression, mode, context: context);

    if (result is EvalSuccess) {
      _ans = result.value;
      _memoryRepo.saveANS(_ans!);
    }

    return result;
  }

  void memoryClear() {
    _memory = 0.0;
    _memoryRepo.saveMemory(_memory);
  }

  void memoryAdd() {
    if (_ans != null) {
      _memory += _ans!;
      _memoryRepo.saveMemory(_memory);
    }
  }

  void memorySubtract() {
    if (_ans != null) {
      _memory -= _ans!;
      _memoryRepo.saveMemory(_memory);
    }
  }

  double memoryRecall() => _memory;
}
import 'package:app/core/evaluator/eval_types.dart';
import 'package:app/repositories/function_repository.dart';

import '../models/custom_function.dart';

class FunctionService {
  final FunctionRepository _repo;
  final Map<String, FunctionDef> _functions = {};
  final List<CustomFunction> _raw = [];

  FunctionService(this._repo);
  List<CustomFunction> get currentFunctions => List.unmodifiable(_raw);

  Future<void> restore() async {
    final list = await _repo.load();
    setFunctions(list);
  }

  void setFunctions(List<CustomFunction> list) {
    _raw
      ..clear()
      ..addAll(list);

    _functions
      ..clear()
      ..addEntries(
        list.map((f) => MapEntry(f.name, FunctionDef(f.parameters, f.formula))),
      );

    _repo.save(list);
  }

  Map<String, FunctionDef> get functions => _functions;
}
import 'package:flutter/material.dart';

import '../services/calculator_service.dart';
import '../services/function_service.dart';
import '../core/evaluator/eval_context.dart';
import '../core/evaluator/eval_types.dart';

class CalculatorState extends ChangeNotifier {
  final CalculatorService calculator;
  final FunctionService functions;

  String display = '0';
  String expression = '';
  int cursor = 0;
  AngleMode angleMode = AngleMode.rad;

  int _parenBalance = 0;

  CalculatorState(this.calculator, this.functions);

  // ===============================
  // PUBLIC ENTRY POINT (ONLY ONE)
  // ===============================
  void input(String value) {
    // CLEAR
    if (value == 'C') {
      _reset();
      return;
    }

    // TOGGLE ANGLE
    if (value == 'RAD/DEG') {
      angleMode = angleMode == AngleMode.rad ? AngleMode.deg : AngleMode.rad;
      notifyListeners();
      return;
    }

    // EVALUATE
    if (value == '=') {
      _evaluate();
      return;
    }

    // DELETE
    if (value == 'DEL') {
      _delete();
      return;
    }

    // MEMORY OPS
    if (value == 'MC') {
      calculator.memoryClear();
      return;
    }
    if (value == 'MR') {
      _insert(calculator.memoryRecall().toString());
      return;
    }
    if (value == 'M+') {
      calculator.memoryAdd();
      return;
    }
    if (value == 'M-') {
      calculator.memorySubtract();
      return;
    }

    // APPEND (GRAMMAR-GUARDED)
    if (!_canAppend(value)) return;
    _insert(value);
  }

  // ===============================
  // INTERNAL HELPERS
  // ===============================

  void _reset() {
    display = '0';
    expression = '';
    _parenBalance = 0;
    cursor = 0;
    notifyListeners();
  }

  void _delete() {
    if (cursor == 0 || expression.isEmpty) return;

    final removed = expression[cursor - 1];

    expression = expression.replaceRange(cursor - 1, cursor, '');

    cursor--;

    if (removed == '(') _parenBalance--;
    if (removed == ')') _parenBalance++;

    display = expression.isEmpty ? '0' : expression;
    notifyListeners();
  }

  void _insert(String value) {
    expression = expression.replaceRange(cursor, cursor, value);

    cursor += value.length;
    display = expression;

    if (value == '(') _parenBalance++;
    if (value == ')') _parenBalance--;

    notifyListeners();
  }

  void _evaluate() {
    if (_parenBalance != 0) {
      display = 'Error';
      expression = '';
      _parenBalance = 0;
      notifyListeners();
      return;
    }

    final result = calculator.evaluate(
      expression,
      angleMode,
      EvalContext(functions: functions.functions),
    );

    if (result is EvalSuccess) {
      final formatted = result.value
          .toStringAsFixed(10)
          .replaceFirst(RegExp(r'\.0+$'), '')
          .replaceFirst(RegExp(r'(\.\d*?)0+$'), r'\1');

      display = formatted;
      expression = formatted;
    } else {
      display = 'Error';
      expression = '';
      _parenBalance = 0;
    }
    notifyListeners();
  }

  // ===============================
  // GRAMMAR ENFORCEMENT
  // ===============================

  bool _canAppend(String value) {
    if (expression.isEmpty) {
      return !'*/^)'.contains(value);
    }

    final left = cursor == 0 ? '' : expression[cursor - 1];
    final right = cursor == expression.length ? '' : expression[cursor];

    // Operators
    if ('+-*/^'.contains(value)) {
      if (left.isEmpty || '+-*/^('.contains(left)) {
        return value == '-'; // unary minus only
      }
    }

    // Decimal
    if (value == '.') {
      final parts = expression.split(RegExp(r'[+\-*/^()]'));
      return !parts.last.contains('.');
    }

    // Right parenthesis
    if (value == ')') {
      if (_parenBalance == 0) return false;
      if (right.isEmpty || '+-*/^('.contains(right)) return false;
    }

    return true;
  }

  void moveCursorLeft() {
    if (cursor > 0) {
      cursor--;
      notifyListeners();
    }
  }

  void moveCursorRight() {
    if (cursor < expression.length) {
      cursor++;
      notifyListeners();
    }
  }

  void setCursor(int index) {
    cursor = index.clamp(0, expression.length);
    notifyListeners();
  }
}
import 'dart:math' as math;

class MatrixOperations {
  static List<List<double>> add(List<List<double>> a, List<List<double>> b) {
    if (a.length != b.length || a[0].length != b[0].length) {
      throw Exception('Dimension mismatch');
    }

    return List.generate(
      a.length,
      (i) => List.generate(a[0].length, (j) => a[i][j] + b[i][j]),
    );
  }

  static List<List<double>> multiply(
    List<List<double>> a,
    List<List<double>> b,
  ) {
    if (a[0].length != b.length) {
      throw Exception('Cannot multiply: incompatible dimensions');
    }

    return List.generate(
      a.length,
      (i) => List.generate(b[0].length, (j) {
        double sum = 0;
        for (int k = 0; k < a[0].length; k++) {
          sum += a[i][k] * b[k][j];
        }
        return sum;
      }),
    );
  }

  static double determinant(List<List<double>> matrix) {
    final n = matrix.length;
    if (n != matrix[0].length) {
      throw Exception('Matrix must be square');
    }

    if (n == 1) return matrix[0][0];
    if (n == 2) {
      return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
    }

    double det = 0;
    for (int col = 0; col < n; col++) {
      det +=
          math.pow(-1, col) *
          matrix[0][col] *
          determinant(_getMinor(matrix, 0, col));
    }
    return det;
  }

  static List<List<double>> transpose(List<List<double>> matrix) {
    return List.generate(
      matrix[0].length,
      (i) => List.generate(matrix.length, (j) => matrix[j][i]),
    );
  }

  static List<List<double>> _getMinor(
    List<List<double>> matrix,
    int row,
    int col,
  ) {
    return matrix
        .asMap()
        .entries
        .where((e) => e.key != row)
        .map(
          (e) => e.value
              .asMap()
              .entries
              .where((c) => c.key != col)
              .map((c) => c.value)
              .toList(),
        )
        .toList();
  }

  static String formatMatrix(List<List<double>> matrix) {
    return matrix
        .map((row) => '[${row.map((v) => v.toStringAsFixed(2)).join(', ')}]')
        .join('\n');
  }
}
class ModuloOperations {
  static int _checkMod(int mod) {
    if (mod <= 0) {
      throw Exception('Modulo must be positive');
    }
    return mod;
  }

  static int _norm(int x, int mod) {
    return ((x % mod) + mod) % mod;
  }

  static int add(int a, int b, int mod) {
    mod = _checkMod(mod);
    return _norm(a + b, mod);
  }

  static int subtract(int a, int b, int mod) {
    mod = _checkMod(mod);
    return _norm(a - b, mod);
  }

  static int multiply(int a, int b, int mod) {
    mod = _checkMod(mod);
    return _norm(a * b, mod);
  }

  static int power(int base, int exp, int mod) {
    mod = _checkMod(mod);
    base = _norm(base, mod);

    if (exp < 0) {
      throw Exception('Negative exponent not supported in modulo arithmetic');
    }

    int result = 1;
    while (exp > 0) {
      if (exp & 1 == 1) result = (result * base) % mod;
      exp >>= 1;
      base = (base * base) % mod;
    }
    return result;
  }

  static int inverse(int a, int mod) {
    mod = _checkMod(mod);
    a = _norm(a, mod);

    final res = _extendedGCD(a, mod);
    if (res.gcd != 1) {
      throw Exception('Inverse does not exist (numbers not coprime)');
    }
    return _norm(res.x, mod);
  }

  static _EGCDResult _extendedGCD(int a, int b) {
    if (b == 0) {
      return _EGCDResult(a, 1, 0);
    }
    final r = _extendedGCD(b, a % b);
    return _EGCDResult(r.gcd, r.y, r.x - (a ~/ b) * r.y);
  }
}

class _EGCDResult {
  final int gcd;
  final int x;
  final int y;

  const _EGCDResult(this.gcd, this.x, this.y);
}
class UnitConversions {
  static const List<String> categories = [
    'Length',
    'Weight',
    'Temperature',
    'Area',
    'Volume',
  ];

  // Multiplicative conversions only (NON-temperature)
  static final Map<String, Map<String, double>> _factors = {
    'Length': {
      'meter': 1.0,
      'kilometer': 0.001,
      'centimeter': 100.0,
      'mile': 0.000621371,
      'yard': 1.09361,
      'foot': 3.28084,
      'inch': 39.3701,
    },
    'Weight': {
      'kilogram': 1.0,
      'gram': 1000.0,
      'pound': 2.20462,
      'ounce': 35.274,
      'ton': 0.001,
    },
    'Area': {
      'square_meter': 1.0,
      'square_kilometer': 1e-6,
      'square_mile': 3.861e-7,
      'acre': 0.000247105,
      'hectare': 0.0001,
    },
    'Volume': {
      'liter': 1.0,
      'milliliter': 1000.0,
      'gallon': 0.264172,
      'cubic_meter': 0.001,
    },
  };

  static List<String> getUnitsForCategory(String category) {
    if (category == 'Temperature') {
      return const ['celsius', 'fahrenheit', 'kelvin'];
    }

    final units = _factors[category];
    if (units == null) {
      throw Exception('Unknown category: $category');
    }
    return units.keys.toList();
  }

  static double convert(
    double value,
    String category,
    String fromUnit,
    String toUnit,
  ) {
    if (category == 'Temperature') {
      return _convertTemperature(value, fromUnit, toUnit);
    }

    final cat = _factors[category];
    if (cat == null) {
      throw Exception('Unknown category: $category');
    }

    final fromFactor = cat[fromUnit];
    final toFactor = cat[toUnit];

    if (fromFactor == null || toFactor == null) {
      throw Exception('Invalid unit for $category');
    }

    // Convert via base unit
    return value * (toFactor / fromFactor);
  }

  static double _convertTemperature(double value, String from, String to) {
    double celsius;

    switch (from) {
      case 'celsius':
        celsius = value;
        break;
      case 'fahrenheit':
        celsius = (value - 32) * 5 / 9;
        break;
      case 'kelvin':
        celsius = value - 273.15;
        break;
      default:
        throw Exception('Invalid temperature unit');
    }

    switch (to) {
      case 'celsius':
        return celsius;
      case 'fahrenheit':
        return celsius * 9 / 5 + 32;
      case 'kelvin':
        return celsius + 273.15;
      default:
        throw Exception('Invalid temperature unit');
    }
  }
}
import 'package:flutter/material.dart';

class CalculatorButton extends StatelessWidget {
  final String text;
  final Color color;
  final Function(String) onPressed;

  const CalculatorButton({
    Key? key,
    required this.text,
    required this.color,
    required this.onPressed,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: () => onPressed(text),
      style: ElevatedButton.styleFrom(
        backgroundColor: color,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
      ),
      child: Text(
        text,
        textAlign: TextAlign.center,
        style: const TextStyle(fontSize: 18),
      ),
    );
  }
}
import 'package:app/core/evaluator/eval_context.dart';
import 'package:app/core/evaluator/eval_types.dart';
import 'package:app/core/evaluator/expression_evaluator.dart';
import 'package:app/services/function_service.dart';
import 'package:flutter/material.dart';
import '../models/custom_function.dart';
import 'package:provider/provider.dart';

class FunctionTestDialog extends StatefulWidget {
  final CustomFunction function;
  const FunctionTestDialog({Key? key, required this.function})
    : super(key: key);

  @override
  State<FunctionTestDialog> createState() => _FunctionTestDialogState();
}

class _FunctionTestDialogState extends State<FunctionTestDialog> {
  final Map<String, TextEditingController> _controllers = {};
  String _result = '';
  final ExpressionEvaluator _evaluator = ExpressionEvaluator();

  @override
  void initState() {
    super.initState();
    for (final p in widget.function.parameters) {
      _controllers[p] = TextEditingController();
    }
  }

  void _calculate() {
    try {
      String expr = widget.function.formula;

      for (final param in widget.function.parameters) {
        final value = _controllers[param]!.text.trim();
        if (value.isEmpty) {
          throw const EvalError(
            EvalErrorType.syntax,
            'All parameters must have values',
          );
        }

        // Replace only whole identifiers
        expr = expr.replaceAllMapped(
          RegExp(r'\b' + RegExp.escape(param) + r'\b'),
          (_) => value,
        );
      }
      final functionService = context.read<FunctionService>();

      final result = _evaluator.evaluate(
        expr,
        AngleMode.rad,
        context: EvalContext(functions: functionService.functions),
      );

      setState(() {
        if (result is EvalSuccess) {
          _result = result.value
              .toStringAsFixed(6)
              .replaceFirst(RegExp(r'\.0+$'), '')
              .replaceFirst(RegExp(r'(\.\d*?)0+$'), r'\1');
        } else if (result is EvalError) {
          _result = 'Error: ${result.message}';
        }
      });
    } catch (e) {
      setState(() {
        _result = 'Error';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text('Test ${widget.function.name}'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ...widget.function.parameters.map(
              (p) => Padding(
                padding: const EdgeInsets.only(bottom: 12),
                child: TextField(
                  controller: _controllers[p],
                  decoration: InputDecoration(
                    labelText: p,
                    border: const OutlineInputBorder(),
                  ),
                  keyboardType: TextInputType.number,
                ),
              ),
            ),
            const SizedBox(height: 12),
            ElevatedButton(
              onPressed: _calculate,
              child: const Text('Calculate'),
            ),
            const SizedBox(height: 16),
            if (_result.isNotEmpty)
              Card(
                color: Colors.green.shade900,
                child: Padding(
                  padding: const EdgeInsets.all(12),
                  child: Text(
                    'Result: $_result',
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Close'),
        ),
      ],
    );
  }

  @override
  void dispose() {
    for (final c in _controllers.values) {
      c.dispose();
    }
    super.dispose();
  }
}
import 'package:flutter/material.dart';

class MatrixInput extends StatelessWidget {
  final List<List<double>> matrix;
  final int rows;
  final int cols;
  final Function(int, int, double) onChanged;

  const MatrixInput({
    Key? key,
    required this.matrix,
    required this.rows,
    required this.cols,
    required this.onChanged,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Column(
      children: List.generate(
        rows,
        (i) => Row(
          children: List.generate(
            cols,
            (j) => Expanded(
              child: Padding(
                padding: const EdgeInsets.all(4),
                child: TextField(
                  decoration: const InputDecoration(
                    hintText: '0',
                    border: OutlineInputBorder(),
                    contentPadding: EdgeInsets.all(8),
                  ),
                  keyboardType: TextInputType.number,
                  onChanged: (v) {
                    final value = double.tryParse(v) ?? 0;
                    onChanged(i, j, value);
                  },
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

